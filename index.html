<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://bundle.run/varuint-bitcoin@1.1.2"></script>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script src="https://bundle.run/bip39@3.0.4"></script>
        <script src="https://bundle.run/bip32@2.0.6"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            input[ type="checkbox" ] {
                line-height: normal;
                width: 1rem;
                height: 1rem;
                font-size: medium;
                border: none;
            }
            .offer, .bordered {
                border: 1px solid black;
                padding: 1rem;
                margin-bottom: 1rem;
            }
            .offer div {
                margin-bottom: 1rem;
            }
            .offer .fill_in_details, .bordered .fill_in_details {
                display: none;
            }
            .offer_wizard {
                display: none;
            }
            .flexy_box {
                display: flex;
                justify-content: space-around;
            }
            .pick_borrow_or_lend {
                display: none;
            }
            .loan_offer {
                display: none;
            }
            .offer_url {
                display: none;
                word-wrap: break-word;
            }
            .wallet div {
                width: 100%;
                text-align: center;
            }
            .btc_wallet {
                border-right: 1px solid black;
            }
            .wallet_container {
                padding: 1rem 0rem;
            }
            .hide_private_keys {
                display: none;
            }
            .private_keys {
                display: none;
                text-align: center;
            }
            .deposit_and_withdrawal_box {
                display: none;
                margin-top: calc( -1rem - 1px );
                text-align: center;
            }
            .wallet_buttons p {
                margin-bottom: 0px;
            }
            @media screen and (max-width: 600px) {
                .wallet_buttons {
                    display: block;
                }
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var myKeyPair = bitcoinjs.ECPair.makeRandom();
            var myBTCKey = myKeyPair.publicKey;
            var preimage_for_lender = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
            var pmthash_for_lender = bitcoinjs.crypto.hash160( buffer.Buffer.from( preimage_for_lender, "hex" ) ).toString( "hex" );
        </script>
        <script>
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }

            function isValidAddress( address ) {
                try{
                    return ( typeof( bitcoinjs.address.toOutputScript( address, bitcoinjs.networks.testnet ) ) == "object" );
                } catch( e ) {
                    return;
                }
            }
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }

            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = window.crypto.getRandomValues(new Uint8Array(16));
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
            async function getBitcoinPriceFromCoinbase() {
                    var data = await getData( "https://api.coinbase.com/v2/prices/BTC-USD/spot" );
                    var json = JSON.parse( data );
                    var price = json[ "data" ][ "amount" ];
                    return price;
            }
            async function getData( url ) {
                var rtext = "";
                function inner_get( url ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "GET", url, true );
                    xhttp.send();
                    return xhttp;
                }
                var data = inner_get( url );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }

            async function getBitcoinPriceFromKraken() {
                    var data = await getData( "https://api.kraken.com/0/public/Ticker?pair=XBTUSD" );
                    var json = JSON.parse( data );
                    var price = json[ "result" ][ "XXBTZUSD" ][ "a" ][ 0 ];
                    return price;
            }

            async function getBitcoinPriceFromCoindesk() {
                    var data = await getData( "https://api.coindesk.com/v1/bpi/currentprice.json" );
                    var json = JSON.parse( data );
                    var price = json[ "bpi" ][ "USD" ][ "rate_float" ];
                    return price;
            }

            async function getBitcoinPriceFromGemini() {
                    var data = await getData( "https://api.gemini.com/v2/ticker/BTCUSD" );
                    var json = JSON.parse( data );
                    var price = json[ "bid" ];
                    return price;
            }

            async function getBitcoinPriceFromBybit() {
                    var data = await getData( "https://api-testnet.bybit.com/derivatives/v3/public/order-book/L2?category=linear&symbol=BTCUSDT" );
                    var json = JSON.parse( data );
                    var price = json[ "result" ][ "b" ][ 0 ][ 0 ];
                    return price;
            }

            async function getBitcoinPrice() {
                var prices = [];
                var cbprice = await getBitcoinPriceFromCoinbase();
                var kprice = await getBitcoinPriceFromKraken();
                var cdprice = await getBitcoinPriceFromCoindesk();
                var gprice = await getBitcoinPriceFromGemini();
                var bprice = await getBitcoinPriceFromBybit();
                prices.push( Number( cbprice ), Number( kprice ), Number( cdprice ), Number( gprice ), Number( bprice ) );
                prices.sort();
                //console.log( prices );
                return prices[ 2 ];
            }
            async function checkPrice() {
                var price = await getBitcoinPrice();
                sessionStorage[ "bitcoin_price" ] = price;
            }
            function heartbeat() {
                checkPrice();
                setTimeout( function() {heartbeat();}, 10000 );
            }
            heartbeat();
            function satsToBitcoin( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                var number = Number( String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 ) ).toFixed( 8 );
                if ( number.slice( -6 ) == "000000" ) number = number.slice( 0, -6 );
                return number;
            }
            async function satsToDollars( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                var bitcoin_price = sessionStorage[ "bitcoin_price" ];
                var value_in_dollars = Number( String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 ) ) * bitcoin_price;
                return value_in_dollars;
            }
            function isValidJson( content ) {
                if ( !content ) return;
                try {  
                    var json = JSON.parse( content );
                } catch ( e ) {
                    return;
                }
                return true;
            }
            function generateHtlcWithBorrowerTimelocked( borrowerPubkey, lenderPubkey, pmthash, timelock ) {
                  if ( borrowerPubkey == lenderPubkey ) {
                    alert( `aborting and refreshing the page! Something went terribly wrong, please try again.` );
                    window.location.reload();
                  }
                  var num1 = BigInt( "0x" + borrowerPubkey );
                  var num2 = BigInt( "0x" + lenderPubkey );
                  if ( num1 > num2 ) {
                    var key1 = borrowerPubkey;
                    var key2 = lenderPubkey;
                  } else {
                      var key1 = lenderPubkey;
                    var key2 =borrowerPubkey;
                  }
                  return bitcoinjs.script.fromASM(
                    `
                        OP_HASH160
                        ${ pmthash }
                        OP_EQUAL
                        OP_IF
                            ${ key1 }
                            OP_CHECKSIG
                            OP_SWAP
                            ${ key2 }
                            OP_CHECKSIG
                            OP_ADD
                            OP_2
                            OP_EQUAL
                          OP_ELSE
                            ${ bitcoinjs.script.number.encode( timelock ).toString( "hex" ) }
                            OP_CHECKLOCKTIMEVERIFY
                            OP_DROP
                            ${ borrowerPubkey }
                            OP_CHECKSIG
                          OP_ENDIF
                    `
                    .trim()
                    .replace( /\s+/g, " " ),
                  );
            }

            function generateHtlcWithLenderTimelocked( lenderPubkey, borrowerPubkey, pmthash, timelock ) {
                  return bitcoinjs.script.fromASM(
                    `
                        OP_HASH160
                        ${ pmthash }
                        OP_EQUAL
                        OP_IF
                            ${ borrowerPubkey }
                          OP_ELSE
                            ${ bitcoinjs.script.number.encode( timelock ).toString( "hex" ) }
                            OP_CHECKLOCKTIMEVERIFY
                            OP_DROP
                            ${ lenderPubkey }
                          OP_ENDIF
                        OP_CHECKSIG
                    `
                    .trim()
                    .replace( /\s+/g, " " ),
                  );
            }

            async function getBlockheight() {
                var data = await getData( "https://mempool.space/testnet/api/blocks/tip/height" );
                return Number( data );
            }
            function make2of2MultisigOutputScript( firstpubkey, secondpubkey ) {
                  var num1 = BigInt( "0x" + firstpubkey );
                  var num2 = BigInt( "0x" + secondpubkey );
                  if ( num1 > num2 ) {
                    var key1 = firstpubkey;
                    var key2 = secondpubkey;
                  } else {
                      var key1 = secondpubkey;
                    var key2 =firstpubkey;
                  }
                var p2ms = bitcoinjs.payments.p2ms( {
                    m: 2, pubkeys: [
                        buffer.Buffer.from( key1, 'hex' ),
                        buffer.Buffer.from( key2, 'hex' ),
                    ], network: bitcoinjs.networks.testnet} );
                return p2ms;
            }
            function decimalToHex( dec ) {
                dec = dec * 100000000;
                var hex = dec.toString( 16 );
                var padding = "0000000000000000";
                padding = padding + hex;
                hex = padding.slice( -16 );
                return hex;
            }

            function witnessStackToScriptWitness(witness) {
                let buffer2 = buffer.Buffer.allocUnsafe(0);
                function writeSlice(slice) {
                    buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.from(slice)]);
                }
                function writeVarInt(i) {
                    const currentLen = buffer2.length;
                    const varintLen = varuintBitcoin.encodingLength(i);
                    buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.allocUnsafe(varintLen)]);
                    varuintBitcoin.encode(i, buffer2, currentLen);
                }
                function writeVarSlice(slice) {
                    writeVarInt(slice.length);
                    writeSlice(slice);
                }
                function writeVector(vector) {
                    writeVarInt(vector.length);
                    vector.forEach(writeVarSlice);
                }
                writeVector(witness);
                return buffer2;
            }
            function waitSomeSeconds( num ) {
                var num = num.toString() + "000";
                num = Number( num );
                return new Promise( function( resolve, reject ) {
                    setTimeout( function() { resolve( "" ); }, num );
                });
            }

            function computeRawPrivkey( node ) {
                return bitcoinjs.ECPair.fromPrivateKey( node.privateKey, { network: bitcoinjs.networks.testnet } ).privateKey.toString( "hex" );
            }

            function getNestedSegwitAddressFromPrivkeyHex( privkeyhex ) {
                var ecPair = bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( privkeyhex, 'hex' ), bitcoinjs.networks.testnet );
                var { address } = bitcoinjs.payments.p2sh({ 
                    redeem: bitcoinjs.payments.p2wpkh({ pubkey: ecPair.publicKey, network: bitcoinjs.networks.testnet }),
                    network: bitcoinjs.networks.testnet 
                });
                return address;
            }

            function getPrivkeyHexFromPath( backupwords, path, index ) {
                //standard segwit path is m/84'/0'/0'/0 so “path” should be 84'/0'/0' and “index” 0
                var seed = bip39.mnemonicToSeedSync( backupwords );
                var node = bip32.fromSeed( seed );
                var path = "m/" + path + "/" + index;
                var root = node;
                var child = root.derivePath( path );
                return computeRawPrivkey( child );
            }

            function getCompressedPubkeyHexFromPrivkeyHex( privkeyhex ) {
                return bitcoinjs.ECPair.fromPrivateKey( Buffer.from( privkeyhex, "hex" ), { network: bitcoinjs.networks.testnet } ).publicKey.toString( "hex" );
            }

            async function getUTXOs( privkey ) {
                var pubkey = getCompressedPubkeyHexFromPrivkeyHex( privkey );
                var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                var esplorautxos = await getData( "https://mempool.space/testnet/api/address/" + address + "/utxo" );
                esplorautxos = JSON.parse( esplorautxos );
                var obj = [];
                var i; for ( i=0; i<esplorautxos.length; i++ ) {
                    var item = esplorautxos[ i ];
                    var index = i;
                    var utxo = {}
                    var prev_tx_hex = await getData( "https://mempool.space/testnet/api/tx/" + item[ "txid" ] + "/hex" );
                    utxo[ "prev_tx_hex" ] = prev_tx_hex;
                    utxo[ "output_number" ] = item[ "vout" ];
                    utxo[ "amount" ] = item[ "value" ];
                    utxo[ "tx_id" ] = item[ "txid" ];
                    utxo[ "privkey" ] = privkey;
                    utxo[ "pubkey" ] = pubkey;
                    obj.push( utxo );
                }
                return( obj );
            }

            async function getUsdtUTXOs( privkey ) {
                var pubkey = getCompressedPubkeyHexFromPrivkeyHex( privkey );
                var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                var esplorautxos = await getData( "https://mempool.space/testnet/api/address/" + address + "/utxo" );
                esplorautxos = JSON.parse( esplorautxos );
                var obj = [];
                var i; for ( i=0; i<esplorautxos.length; i++ ) {
                    var item = esplorautxos[ i ];
                    var index = i;
                    var utxo = {}
                    var prev_tx_hex = await getData( "https://mempool.space/testnet/api/tx/" + item[ "txid" ] + "/hex" );
                    utxo[ "prev_tx_hex" ] = prev_tx_hex;
                    utxo[ "output_number" ] = item[ "vout" ];
                    utxo[ "amount" ] = item[ "value" ];
                    utxo[ "tx_id" ] = item[ "txid" ];
                    utxo[ "privkey" ] = privkey;
                    utxo[ "pubkey" ] = pubkey;
                    obj.push( utxo );
                }
                return( obj );
            }

            async function getAddressBalance( address ) {
                    var json = await getData( "https://mempool.space/testnet/api/address/" + address );
                    json = JSON.parse( json );
                    var fullincome = json[ "chain_stats" ][ "funded_txo_sum" ] + json[ "mempool_stats" ][ "funded_txo_sum" ];
                    var fulloutgo = json[ "chain_stats" ][ "spent_txo_sum" ] + json[ "mempool_stats" ][ "spent_txo_sum" ];
                    return fullincome - fulloutgo;
            }

            async function didThisAddressEverHaveMoney( address ) {
                var json = await getData( "https://mempool.space/testnet/api/address/" + address );
                json = JSON.parse( json );
                if ( json[ "chain_stats" ][ "funded_txo_count" ] > 0 || json[ "mempool_stats" ][ "funded_txo_count" ] > 0 ) {
                    return true;
                }
                return;
            }

            async function getAvailableUtxosFromReceivePath() {
                return new Promise( async function( resolve, reject ) {
                    var available_utxos = [];
                    var i1 = 0;
                    var i2 = 0;
                    var i; for ( i=0; i<100000; i++ ) {
                        var starting_index = 0;
                        var starting_change_index = 0;
                        if ( i2 > starting_index + 20 ) {
                            break;
                        }
                        var backupwords = localStorage[ "backup_words" ];
                        var path = "84'/0'/0'";
                        var privkey = getPrivkeyHexFromPath( backupwords, path, i1 + i2 );
                        var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                        var balance = await getAddressBalance( address );
                        if ( balance < 1 ) {
                            i2 = Number( i2 ) + 1;
                        } else {
                            i1 = Number( i1 ) + 1;
                            var utxos_in_this_address = await getUTXOs( privkey );
                            utxos_in_this_address.forEach( function( item ) {
                                available_utxos.push( item );
                            });
                        }
                    }
                    resolve( available_utxos );
                });
            }

            async function getAvailableUtxosFromChangePath() {
                return new Promise( async function( resolve, reject ) {
                    var available_utxos = [];
                    var i1 = 0;
                    var i2 = 0;
                    var i; for ( i=0; i<100000; i++ ) {
                        var starting_index = 0;
                        var starting_change_index = 0;
                        if ( i2 > starting_change_index + 20 ) {
                            break;
                        }
                        var backupwords = localStorage[ "backup_words" ];
                        var path = "84'/0'/1'";
                        var privkey = getPrivkeyHexFromPath( backupwords, path, i1 + i2 );
                        var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                        var balance = await getAddressBalance( address );
                        if ( balance < 1 ) {
                            i2 = Number( i2 ) + 1;
                        } else {
                            i1 = Number( i1 ) + 1;
                            var utxos_in_this_address = await getUTXOs( privkey );
                            utxos_in_this_address.forEach( function( item ) {
                                    available_utxos.push( item );
                            });
                        }
                    }
                    resolve( available_utxos );
                });
            }

            async function getFirstUnusedReceiveAddress() {
                var starting_index = 0;
                var i; for ( i=starting_index; i<100000; i++ ) {
                    var backupwords = localStorage[ "backup_words" ];
                    var path = "84'/0'/0'";
                    var privkey = getPrivkeyHexFromPath( backupwords, path, i );
                    var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                    var hadMoney = await didThisAddressEverHaveMoney( address );
                    if ( !hadMoney ) {
                        //localStorage[ "index-of-first-known-unused-receive-address" ] = i;
                        return address;
                    }
                }
            }

            async function getFirstUnusedChangeAddress() {
                var starting_index = 0;
                var i; for ( i=starting_index; i<100000; i++ ) {
                    var backupwords = localStorage[ "backup_words" ];
                    var path = "84'/0'/1'";
                    var privkey = getPrivkeyHexFromPath( backupwords, path, i );
                    var address = getNestedSegwitAddressFromPrivkeyHex( privkey );
                    var hadMoney = await didThisAddressEverHaveMoney( address );
                    if ( !hadMoney ) {
                        //localStorage[ "index-of-first-known-unused-change-address" ] = i;
                        return address;
                    }
                }
            }

            async function checkAddresses() {
                var first_unused_receive_address = await getFirstUnusedReceiveAddress();
                var first_unused_change_address = await getFirstUnusedChangeAddress();
                var available_utxos_1 = await getAvailableUtxosFromReceivePath();
                var available_utxos_2 = await getAvailableUtxosFromChangePath();
                available_utxos_2.forEach( function( item ) {
                    available_utxos_1.push( item );
                });
                localStorage[ "utxos" ] = JSON.stringify( available_utxos_1 );
            }

            async function getUSDTBalance( address, include_pending ) {
                var data = await postData( `https://api.omniwallet.org/v2/address/addr/`, `addr=${address}`, "application/x-www-form-urlencoded" );

                var property_i_seek;
                try {
                    data = JSON.parse( data );
                } catch( e ) {}
                if ( Object.keys( data )[ 0 ] && data[ Object.keys( data )[ 0 ] ][ "balance" ] ) {
                    data[ Object.keys( data )[ 0 ] ][ "balance" ].every( function( possibility ) {
                        if ( Number( possibility[ "id" ] ) == 31 ) {
                            property_i_seek = possibility;
                            return;
                        }
                        return true;
                    });
                } else {
                    property_i_seek = {}
                    property_i_seek[ "reserved" ] = 0;
                    property_i_seek[ "frozen" ] = 0;
                    property_i_seek[ "pendingneg" ] = 0;
                    property_i_seek[ "value" ] = 0;
                }
                var balance = ( Number( property_i_seek[ "value" ] ) - Number( property_i_seek[ "reserved" ] ) - Number( property_i_seek[ "frozen" ] ) - Number( property_i_seek[ "pendingneg" ] ) ) / 100000000;
                if ( include_pending ) {
                    balance = ( Number( property_i_seek[ "value" ] ) + Number( property_i_seek[ "pendingpos" ] ) - Number( property_i_seek[ "reserved" ] ) - Number( property_i_seek[ "frozen" ] ) - Number( property_i_seek[ "pendingneg" ] ) ) / 100000000;
                }
                return balance;
            }

            async function pushBTCpmt( rawtx ) {
                var success = await postData( "https://mempool.space/testnet/api/tx", rawtx );
                return success;
            }

            function craftTransaction( selected_utxos, to_amount, to_address, change_address, change_amount, sats_per_byte ) {
                if ( !to_amount ) {
                    return;
                }
                if ( change_amount != 0 && change_address != "none" ) {
                    //do the part of step 11 where you create a raw bitcoin transaction, and do it with a change address
                    var psbt = new bitcoinjs.Psbt({ network: bitcoinjs.networks.testnet });
                    var i; for ( i=0; i<selected_utxos.length; i++ ) {
                        var redeemscript = "0014" + bitcoinjs.crypto.hash160(
                            Buffer.from( selected_utxos[ i ][ "pubkey" ], "hex" )
                        ).toString( 'hex' );
                        psbt.addInput({
                            hash: selected_utxos[ i ][ "tx_id" ],
                            index: selected_utxos[ i ][ "output_number" ],
                            nonWitnessUtxo: Buffer.from(
                                selected_utxos[ i ][ "prev_tx_hex" ],
                                'hex',
                            ),
                            redeemScript: Buffer.from( redeemscript, "hex" ),
                        });
                    }
                    psbt.addOutput({
                        address: to_address,
                        value: to_amount,
                    });
                    psbt.addOutput({
                        address: change_address,
                        value: change_amount,
                    });
                    var keyPairSenders = [];
                    var i; for ( i=0; i<selected_utxos.length; i++ ) {
                        keyPairSenders.push( bitcoinjs.ECPair.fromPrivateKey( Buffer.from( selected_utxos[ i ][ "privkey" ], "hex" ), bitcoinjs.networks.testnet ) );
                    }
                    var i; for ( i=0; i<keyPairSenders.length; i++ ) {
                        psbt.signInput( i, keyPairSenders[ i ] );
                    }
                    var i; for ( i=0; i<keyPairSenders.length; i++ ) {
                        //psbt.validateSignaturesOfInput( i );
                    }
                    psbt.finalizeAllInputs();
                    return psbt.extractTransaction().toHex();
                } else {
                    //do the part of step 11 where you create a raw bitcoin transaction, and do it without a change address
                    var psbt = new bitcoinjs.Psbt({ network: bitcoinjs.networks.testnet });
                    var i; for ( i=0; i<selected_utxos.length; i++ ) {
                        psbt.addInput({
                            hash: selected_utxos[ i ][ "tx_id" ],
                            index: selected_utxos[ i ][ "output_number" ],
                            witnessUtxo: {
                                script: Buffer.from( '0014' + bitcoinjs.crypto.hash160( Buffer.from( selected_utxos[ i ][ "pubkey" ], "hex" ) ).toString( 'hex' ), 'hex' ),
                                value: selected_utxos[ i ][ "amount" ],
                            },
                        });
                    }
                    psbt.addOutput({
                        address: to_address,
                        value: to_amount,
                    });
                    var keyPairSenders = [];
                    var i; for ( i=0; i<selected_utxos.length; i++ ) {
                        keyPairSenders.push( bitcoinjs.ECPair.fromPrivateKey( Buffer.from( selected_utxos[ i ][ "privkey" ], "hex" ), bitcoinjs.networks.testnet ) );
                    }
                    var i; for ( i=0; i<keyPairSenders.length; i++ ) {
                        psbt.signInput( i, keyPairSenders[ i ] );
                    }
                    var i; for ( i=0; i<keyPairSenders.length; i++ ) {
                        //psbt.validateSignaturesOfInput( i );
                    }
                    psbt.finalizeAllInputs();
                    return psbt.extractTransaction().toHex();
                }
            }

            function addUtxosToTx( amount_plus_fee, utxos_available_for_this_transaction, utxos_in_this_transaction, sats_per_byte, this_addition_is_being_done_because_of_a_change_address = false ) {   
                if ( !amount_plus_fee ) {
                    return;   
                }
                var original_utxos_available_for_this_transaction = JSON.stringify( utxos_available_for_this_transaction );
                var original_utxos_in_this_transaction = JSON.stringify( utxos_in_this_transaction );
                //console.log( "amount plus fee:", amount_plus_fee );
                //console.log( "utxos available for this transaction:", utxos_available_for_this_transaction );
                //console.log( "utxos in this transaction:", utxos_in_this_transaction );
                //4. Check if there are any utxos in an array called utxos_available_for_this_transaction.
                if ( utxos_available_for_this_transaction.length < 1 ) {
                    //if not, throw an error telling the user that they do not have enough money and to either top up their wallet or send a smaller amount.
                    alert( "You do not have enough money to send this transaction. Please top up your wallet or send a smaller amount." );
                } else {
                    //5. Otherwise, add the utxo with the largest value as an input to the transaction and remove it from utxos_available_for_this_transaction. Also recalculate amount_plus_fee $
                    var largest_utxo_value = 0;
                    var largest_utxo_indexnum = 0;
                    var i; for ( i=0; i<utxos_available_for_this_transaction.length; i++ ) {
                        if ( utxos_available_for_this_transaction[ i ][ "amount" ] > largest_utxo_value ) {
                            largest_utxo_value = utxos_available_for_this_transaction[ i ][ "amount" ];
                            largest_utxo_indexnum = i;
                        }
                    }
                    //console.log( "largest_utxo_indexnum", largest_utxo_indexnum );
                    //console.log( "value of largest utxo", utxos_available_for_this_transaction[ largest_utxo_indexnum ][ "amount" ] );
                    utxos_in_this_transaction.push( utxos_available_for_this_transaction.splice( largest_utxo_indexnum, 1 )[ 0 ] );
                    amount_plus_fee = amount_plus_fee + ( 50 * sats_per_byte );
                    //console.log( "the new amount_plus_fee, accounting for the new inputs, is", amount_plus_fee );
                    //6. If the input added in the previous step is the first input to this transaction, treat it as if it was part of a set of multiple inputs.
                    //console.log( "number of utxos in this transaction", utxos_in_this_transaction.length );
                    //7. Check if the sum of the values of each input in the set of inputs is greater than or equal to amount_plus_fee.
                    var sum_of_the_values_of_each_input_to_this_transaction = 0;
                    var i; for ( i=0; i<utxos_in_this_transaction.length; i++ ) {
                        //console.log( "utxo in this transaction whose value we are currently checking so we can sum up the total value of all utxos in this transaction and check if it is g$
                        //console.log( "current utxo", utxos_in_this_transaction[ i ] );
                        //console.log( "amount of current utxo", utxos_in_this_transaction[ i ][ "amount" ] );
                        sum_of_the_values_of_each_input_to_this_transaction = sum_of_the_values_of_each_input_to_this_transaction + utxos_in_this_transaction[ i ][ "amount" ];
                        //console.log( "the sum of the values of each input to this transaction is", sum_of_the_values_of_each_input_to_this_transaction );
                    }
                    if ( sum_of_the_values_of_each_input_to_this_transaction < amount_plus_fee ) {
                        //console.log( "the sum of the values of each input to this transaction, i.e.", sum_of_the_values_of_each_input_to_this_transaction, "was less than the amount we nee$
                        //If the check in step 7 returns false, repeat steps 4-8 until the check in step 7 returns true or until step 4 throws an error.
                        return addUtxosToTx( amount_plus_fee, utxos_available_for_this_transaction, utxos_in_this_transaction, sats_per_byte, false );
                    } else {
                        if ( !this_addition_is_being_done_because_of_a_change_address ) {
                            //9. If the check in step 7 returns true, check if there is change left over and it is greater than or equal to ( 250 + 50*sats_per_byte ) sats (this number $
                            var change_amount = sum_of_the_values_of_each_input_to_this_transaction - amount_plus_fee;
                            //console.log( "the sum of the values of each input to this transaction is", sum_of_the_values_of_each_input_to_this_transaction );
                            //console.log( "amount plus fee", amount_plus_fee );
                            //console.log( "the change amount should be the first number minus the second number, i.e.", change_amount );
                            //console.log( "there is change left over, namely", change_amount, "-- so we have to check if that is more than the dust limit" );
                            if ( change_amount >= ( 250 + 50 * sats_per_byte ) ) {
                                //console.log( "the change amount --", change_amount, "-- is more than the dust limit, which is 250 + 50 * sats_per_byte i.e.", ( 250 + 50 * sats_per$
                                //10. If the check in step 9 returns true, add a change address as an output whose value is equal to whatever value you got in step 9 and redo steps $
                                var we_need_a_change_address = true;
                                new_amount_plus_fee = amount_plus_fee + ( 50*sats_per_byte );
                                //console.log( "original utxos available:", JSON.parse( original_utxos_available_for_this_transaction ) );
                                //console.log( "original utxos in this tx:", JSON.parse( original_utxos_in_this_transaction ) );
                                return addUtxosToTx( new_amount_plus_fee, JSON.parse( original_utxos_available_for_this_transaction ), JSON.parse( original_utxos_in_this_transaction ), sats_per_byte, true );
                            } else {
                                var we_need_a_change_address = false;
                            }
                            //console.log( "sum of the values of each input to this transaction", sum_of_the_values_of_each_input_to_this_transaction );
                            //console.log( "amount_plus_fee", amount_plus_fee );
                            //console.log( "change_amount", change_amount );
                            var array = [];
                            array[ 0 ] = utxos_available_for_this_transaction;
                            array[ 1 ] = utxos_in_this_transaction;
                            array[ 2 ] = amount_plus_fee;
                            array[ 3 ] = change_amount;
                            array[ 4 ] = "the next field is true if we need a change address";
                            array[ 5 ] = this_addition_is_being_done_because_of_a_change_address;
                            return array;
                        } else {
                            var change_amount = sum_of_the_values_of_each_input_to_this_transaction - amount_plus_fee;
                            var array = [];
                            array[ 0 ] = utxos_available_for_this_transaction;
                            array[ 1 ] = utxos_in_this_transaction;
                            array[ 2 ] = amount_plus_fee;
                            array[ 3 ] = change_amount;
                            array[ 4 ] = "the next field is true if we need a change address";
                            array[ 5 ] = this_addition_is_being_done_because_of_a_change_address;
                            return array;
                        }
                    }
                }
            }

            async function sendFromUtxoSetToAddress( toamount, toaddress, sats_per_byte, utxos_available_for_this_transaction, utxos_in_this_transaction ) {
                //console.log( "to amount", toamount );
                //console.log( "sats per byte", sats_per_byte );
                var amount_plus_fee = toamount + ( 150 * sats_per_byte );
                //console.log( "amount_plus_fee", amount_plus_fee );
                var original_utxos_available_for_this_transaction = JSON.stringify( utxos_available_for_this_transaction );
                var original_utxos_in_this_transaction = JSON.stringify( utxos_in_this_transaction );
                var array = addUtxosToTx( amount_plus_fee, utxos_available_for_this_transaction, utxos_in_this_transaction, sats_per_byte, false );
                if ( !array ) {
                    return;
                }
                var adjusted_utxos_available_for_this_transaction = array[ 0 ];
                var adjusted_utxos_in_this_transaction = array[ 1 ];
                amount_plus_fee = array[ 2 ];
                if ( array[ 5 ] ) {
                    var change_amount = array[ 3 ];
                    //console.log( "change_amount", change_amount );
                    var change_address = await getFirstUnusedChangeAddress();
                } else {
                    var change_amount = 0;
                    var change_address = "none";
                }
                //console.log( "adjusted_utxos_available_for_this_transaction", adjusted_utxos_available_for_this_transaction );
                //console.log( "adjusted_utxos_in_this_transaction", adjusted_utxos_in_this_transaction );
                //console.log( "amount_plus_fee", amount_plus_fee );
                var txhex = craftTransaction( adjusted_utxos_in_this_transaction, toamount, toaddress, change_address, change_amount, sats_per_byte );
                //console.log( txhex );
                if ( !txhex ) return;
                var tx = bitcoinjs.Transaction.fromHex( txhex );
                var virtual_bytes = tx.virtualSize();
                var real_fee = virtual_bytes * sats_per_byte;
                var new_amount_plus_fee = toamount + real_fee;
                //console.log( "now I will check what the original utxos available are" );
                //console.log( original_utxos_available_for_this_transaction );
                //console.log( JSON.parse( original_utxos_available_for_this_transaction ) );
                //console.log( "I will also check what the original utxos in the transaction are", JSON.parse( original_utxos_in_this_transaction ) );
                var new_array = addUtxosToTx( new_amount_plus_fee, JSON.parse( original_utxos_available_for_this_transaction ), JSON.parse( original_utxos_in_this_transaction ), sats_per_byte, false );
                var new_adjusted_utxos_available_for_this_transaction = new_array[ 0 ];
                var new_adjusted_utxos_in_this_transaction = new_array[ 1 ];
                new_amount_plus_fee = new_array[ 2 ];
                var new_change_amount = new_array[ 3 ];
                var new_txhex = craftTransaction( new_adjusted_utxos_in_this_transaction, toamount, toaddress, change_address, new_change_amount, sats_per_byte );
                //console.log( new_txhex );
                var new_tx = bitcoinjs.Transaction.fromHex( new_txhex );
                var new_virtual_bytes = tx.virtualSize();
                if ( new_virtual_bytes == virtual_bytes ) {
                    //console.log( "yay! The transaction is ready and here is its hex:", new_txhex );
                    return new_txhex;
                    //do not use this yet because we are only at step 13: pushBTCpmt( new_txhex );
                } else {
                    alert( "I tried to craft your transaction twice and I kept getting errors. Please contact the developer of this wallet for assistance." );
                }
            }

            async function getMinFeeRate() {
                var fees = await getData( "https://mempool.space/api/v1/fees/recommended" );
                fees = JSON.parse( fees );
                if ( !( "minimumFee" in fees ) ) return "error -- site down";
                var minfee = fees[ "minimumFee" ];
                return minfee;
            }

            async function simpleSend( amount, destination, sats_per_byte, skip_alert ) {
                console.log( "fee:", sats_per_byte );
                if ( !sats_per_byte ) sats_per_byte = await getMinFeeRate();
                console.log( "fee:", sats_per_byte );
                var utxos_available_for_this_transaction = JSON.parse( localStorage[ "utxos" ] );
                var utxos_in_this_transaction = [];
                var txhex = await sendFromUtxoSetToAddress( amount, destination, sats_per_byte, utxos_available_for_this_transaction, utxos_in_this_transaction );
                var insValue = 0;
                var outsValue = 0;
                var tx = bitcoinjs.Transaction.fromHex( txhex );
                tx[ "ins" ].forEach( function( input ) {
                    var hash = input[ "hash" ].toString( "hex" );
                    var txid = reverseHexString( hash );
                    var index = input[ "index" ];
                    var value = findUtxoValue( txid, index );
                    insValue = insValue + value;
                });
                tx[ "outs" ].forEach( function( output ) {
                    outsValue = outsValue + output[ "value" ];
                });
                var conf = confirm( `Do you want to send the transaction with this fee? ${insValue - outsValue} sats\nThis is an effective feerate of ${( (insValue - outsValue ) / ( txhex.length / 2 ) ).toFixed( 2 )} sats per byte` );
                if ( !conf ) return;
                var txid = pushBTCpmt( txhex );
                if ( skip_alert ) return txid;
                alert( "success, here is your transaction id:", txid );
                return txid;
            }

            function reverseHexString( s ) {
                return s.match(/[a-fA-F0-9]{2}/g).reverse().join('');
            }

            function findUtxoValue( txid, vout ) {
                var utxos = JSON.parse( localStorage[ "utxos" ] );
                var more_utxos = JSON.parse( localStorage[ "usdt_utxos" ] );
                utxos = utxos.concat( more_utxos );
                var value = 0;
                utxos.every( function( utxo ) {
                    if ( utxo[ "tx_id" ] == txid && utxo[ "output_number" ] == vout ) {
                        value = utxo[ "amount" ];
                        return;
                    }
                    return true;
                });
                return value;
            }

            async function sendUSDT( toamount, toaddress, feerate, usdt_address, skip_alert, send_2000 ) {
                var psbt = new bitcoinjs.Psbt({
                  network: bitcoinjs.networks.testnet,
                });
                var omni_payload = "6f6d6e690000000000000003" + decimalToHex( toamount );
                var data = buffer.Buffer.from( omni_payload, 'hex' );
                var embed = bitcoinjs.payments.embed({ data: [data] });
                var inputs = JSON.parse( localStorage[ "usdt_utxos" ] );
                var extra_inputs = JSON.parse( localStorage[ "utxos" ] );
                utxos.sort( function( a, b ) {
                    return b.amount - a.amount;
                });
                var extra_input = utxos[ 0 ];
                var from_amount = 0;
                inputs.forEach( function( input ) {
                    from_amount = from_amount + input[ "amount" ];
                });
                from_amount = from_amount + extra_input[ "amount" ];
                if ( from_amount < 5000 ) {
                    alert( "You don't have enough sats to do this transaction, put at least 5000 sats in your wallet" );
                    return;
                }
                inputs.forEach( function( input ) {
                    var ecPair = bitcoinjs.ECPair.fromPublicKey( buffer.Buffer.from( input[ "pubkey" ], 'hex' ), bitcoinjs.networks.testnet );
                    var redeemscript = "0014" + bitcoinjs.crypto.hash160( ecPair.publicKey ).toString( 'hex' );
                    psbt.addInput({
                      hash: input[ "tx_id" ],
                      index: input[ "output_number" ],
                      nonWitnessUtxo: buffer.Buffer.from(
                        input[ "prev_tx_hex" ],
                        'hex',
                      ),
                      redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                    });
                });
                //add extra input to pay for gas if necessary
                var ecPair = bitcoinjs.ECPair.fromPublicKey( buffer.Buffer.from( extra_input[ "pubkey" ], 'hex' ), bitcoinjs.networks.testnet );
                var redeemscript = "0014" + bitcoinjs.crypto.hash160( ecPair.publicKey ).toString( 'hex' );
                var change_address = await getFirstUnusedChangeAddress();
                psbt.addInput({
                  hash: extra_input[ "tx_id" ],
                  index: extra_input[ "output_number" ],
                  nonWitnessUtxo: buffer.Buffer.from(
                    extra_input[ "prev_tx_hex" ],
                    'hex',
                  ),
                  redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                });
                psbt.addOutput({
                  script: embed.output,
                  value: 0,
                });
                psbt.addOutput({
                  address: change_address,
                  value: from_amount - ( 546 * 3 ) - 500,
                });
                psbt.addOutput({
                  address: usdt_address,
                  value: 546,
                });
                psbt.addOutput({
                  address: toaddress,
                  value: 546,
                });
                psbt.addOutput({
                  address: toaddress,
                  value: send_2000 ? 2000:546,
                });
                inputs.forEach( function( input, index ) {
                    psbt.signInput( index, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( input[ "privkey" ], "hex" ) ) );
                });
                psbt.signInput( inputs.length, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( extra_input[ "privkey" ], "hex" ) ) );
                psbt.finalizeAllInputs();

                var bytesize = psbt.extractTransaction().toHex().length / 2;
                var realfee = bytesize * feerate;
                var psbt = new bitcoinjs.Psbt({
                  network: bitcoinjs.networks.testnet,
                });
                var omni_payload = "6f6d6e690000000000000003" + decimalToHex( toamount );
                var data = buffer.Buffer.from( omni_payload, 'hex' );
                var embed = bitcoinjs.payments.embed({ data: [data] });
                var inputs = JSON.parse( localStorage[ "usdt_utxos" ] );
                var extra_inputs = JSON.parse( localStorage[ "utxos" ] );
                utxos.sort( function( a, b ) {
                    return b.amount - a.amount;
                });
                var extra_input = utxos[ 0 ];
                var from_amount = 0;
                inputs.forEach( function( input ) {
                    from_amount = from_amount + input[ "amount" ];
                });
                from_amount = from_amount + extra_input[ "amount" ];
                inputs.forEach( function( input ) {
                    var ecPair = bitcoinjs.ECPair.fromPublicKey( buffer.Buffer.from( input[ "pubkey" ], 'hex' ), bitcoinjs.networks.testnet );
                    var redeemscript = "0014" + bitcoinjs.crypto.hash160( ecPair.publicKey ).toString( 'hex' );
                    psbt.addInput({
                      hash: input[ "tx_id" ],
                      index: input[ "output_number" ],
                      nonWitnessUtxo: buffer.Buffer.from(
                        input[ "prev_tx_hex" ],
                        'hex',
                      ),
                      redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                    });
                });
                //add extra input to pay for gas if necessary
                var ecPair = bitcoinjs.ECPair.fromPublicKey( buffer.Buffer.from( extra_input[ "pubkey" ], 'hex' ), bitcoinjs.networks.testnet );
                var redeemscript = "0014" + bitcoinjs.crypto.hash160( ecPair.publicKey ).toString( 'hex' );
                psbt.addInput({
                  hash: extra_input[ "tx_id" ],
                  index: extra_input[ "output_number" ],
                  nonWitnessUtxo: buffer.Buffer.from(
                    extra_input[ "prev_tx_hex" ],
                    'hex',
                  ),
                  redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                });
                psbt.addOutput({
                  script: embed.output,
                  value: 0,
                });
                psbt.addOutput({
                  address: change_address,
                  value: from_amount - ( 546 * 3 ) - realfee,
                });
                psbt.addOutput({
                  address: usdt_address,
                  value: 546,
                });
                psbt.addOutput({
                  address: toaddress,
                  value: 546,
                });
                psbt.addOutput({
                  address: toaddress,
                  value: send_2000 ? 2000:546,
                });
                inputs.forEach( function( input, index ) {
                    psbt.signInput( index, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( input[ "privkey" ], "hex" ) ) );
                });
                psbt.signInput( inputs.length, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( extra_input[ "privkey" ], "hex" ) ) );
                psbt.finalizeAllInputs();
                var insValue = 0;
                var outsValue = 0;
                var tx = psbt.extractTransaction();
                tx[ "ins" ].forEach( function( input ) {
                    var hash = input[ "hash" ].toString( "hex" );
                    var txid = reverseHexString( hash );
                    var index = input[ "index" ];
                    var value = findUtxoValue( txid, index );
                    insValue = insValue + value;
                });
                tx[ "outs" ].forEach( function( output ) {
                    outsValue = outsValue + output[ "value" ];
                });
                var conf = confirm( `Do you want to send the transaction with this fee? ${insValue - outsValue} sats\nThis is an effective feerate of ${( (insValue - outsValue ) / ( psbt.extractTransaction().toHex().length / 2 ) ).toFixed( 2 )} sats per byte` );
                if ( !conf ) return;
                console.log( psbt.extractTransaction().toHex() );
                var txid = pushBTCpmt( psbt.extractTransaction().toHex() );
                if ( skip_alert ) return txid;
                alert( "success, here is your transaction id:", txid );
                return txid;
            }
        </script>
    </head>
    <body>
        <h1>
            Loan shark
        </h1>
        <h2>
            Wallet
        </h2>
        <div class="bordered wallet_container">
            <div class="flexy_box wallet">
                <div class="btc_wallet">
                    <div>
                        You have <span class="btc_balance">loading...</span>
                    </div>
                    <div class="flexy_box wallet_buttons">
                        <p><button class="deposit_btc">Deposit sats</button></p>
                        <p><button class="withdraw_btc">Withdraw sats</button></p>
                    </div>
                </div>
                <div class="usdt_wallet">
                    <div>
                        You have <span class="usdt_balance">loading...</span>
                    </div>
                    <div class="flexy_box wallet_buttons">
                        <p><button class="deposit_usdt">Deposit usdt</button></p>
                        <p><button class="withdraw_usdt">Withdraw usdt</button></p>
                    </div>
                </div>
            </div>
        </div>
        <div class="bordered deposit_and_withdrawal_box"></div>
        <div><button class="view_private_keys">View your private keys</button><button class="hide_private_keys">Hide your private keys</button></div>
        <br>
        <div class="bordered private_keys">These are my private keys</div>
        <h2>
            Orderbook
        </h2>
        <p><button class="new_offer">New offer</button><p>
        <div class="bordered offer_wizard">
            <div class="flexy_box pick_borrow_or_lend">
                <div class="borrow_or_lend"><button class="borrow">I want to borrow bitcoin</button></div>
                <div class="borrow_or_lend"><button class="lend">I want to lend bitcoin</button></div>
            </div>
            <div class="loan_offer">
                <p>
                    What is the minimum amount you want to lend? (in sats) Your offer will be a range between your minimum (chosen here) and a maximum determined by the amount you have in your wallet minus a bit for mining fees.
                </p>
                <div class="min_to_lend">
                    <input type="number" value="546" step="1">
                </div>
                <p>
                    Name your fee (as a percentage)
                </p>
                <p><input class="fee_to_borrow" type="number" value="10" step="1" min="0" max="100"></p>
                <p>
                    How much collateral must your counterparty post? (as a percentage)
                </p>
                <p><input class="collateral_for_loan" type="number" value="200" step="1" min="1" max="1000"></p>
                <p>
                    How long should the loan last?
                    <select class="duration_of_loan">
                        <option>3 months</option>
                        <option>6 months</option>
                        <option>12 months</option>
                    </select>
                </p>
                <p>
                    Keep offer private?
                    <input class="privacy_switch" type="checkbox">
                </p>
                <p><button class="submit_loan_offer">Submit</button></p>
            </div>
        </div>
        <div class="bordered offer_url"></div>
        <div class="orderbook"><div>
        <script>
            var { getSharedSecret, schnorr, utils } = nobleSecp256k1;
            var crypto = window.crypto;
            var getRand = (size) => crypto.getRandomValues(new Uint8Array(size));
            var sha256 = bitcoinjs.crypto.sha256;
            var keypair = bitcoinjs.ECPair.makeRandom();
            var privKey = keypair.privateKey.toString( "hex" );
            var pubKey  = keypair.publicKey.toString( "hex" );
            pubKey      = pubKey.substring( 2 );
            console.log(pubKey);
            //var relay = 'wss://relay.damus.io';
            var relay = 'ws://localhost:8080/';
            var socket = new WebSocket(relay);
            //start the wallet and check its balance every five seconds
            if ( !localStorage[ "backup_words" ] ) {
                localStorage[ "backup_words" ] = bip39.generateMnemonic();
            }
            $( '.private_keys' ).innerText = localStorage[ "backup_words" ];
            socket.addEventListener('message', async function(event) {
                if ( !event.data ) return;
                if ( !JSON.parse( event.data )[ 2 ] ) return;
                event = JSON.parse( event.data )[ 2 ];
                if ( !event || event === true ) return;
                if ( event.kind == 10004 ) {
                    //todo: validate what the borrower sent
                    var content = decrypt( privKey, event.pubkey, event.content );
                    content = JSON.parse( content );
                    var borrowerKeypair = bitcoinjs.ECPair.fromPublicKey( Buffer.from( content.btcpubkey, "hex" ) );
                    var borrowerPubkey = borrowerKeypair.publicKey.toString( "hex" );
                    var lenderKeypair = myKeyPair;
                    var lenderPubkey = lenderKeypair.publicKey.toString( "hex" );
                    var pmthash = pmthash_for_lender;
                    //var blockheight = await getBlockheight();
                    var blockheight = prompt( "Enter blockheight" );
                    blockheight = Number( blockheight );
                    var timelock = blockheight + 10;
                    console.log( "inputs to witness script: borrowerPubkey:", borrowerPubkey, "lenderPubkey:", lenderPubkey, "pmthash:", pmthash, "timelock:", timelock );
                    var witness_script = generateHtlcWithBorrowerTimelocked( borrowerPubkey, lenderPubkey, pmthash, timelock );
                    var htlc_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( witness_script ).toString( 'hex' ), 'hex' ) );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witness_script, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                    var p2sh = bitcoinjs.payments.p2sh({redeem: p2wsh, network: bitcoinjs.networks.testnet});
                    var htlc_address = p2sh.address;
                    console.log( "htlc address:", htlc_address );
                    var claimed_htlc_address = content.htlc_address;
                    if ( claimed_htlc_address != htlc_address ) {
                        //todo: send back failure message
                        alert( "wrong htlc address" );
                        return;
                    }
                    var p2ms = make2of2MultisigOutputScript( borrowerPubkey, lenderPubkey );
                    var multisig_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( p2ms.output ).toString( 'hex' ), 'hex' ) );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: p2ms, network: bitcoinjs.networks.testnet});
                    var p2sh = bitcoinjs.payments.p2sh({redeem: p2wsh, network: bitcoinjs.networks.testnet});
                    var multisig_address = p2sh.address;
                    console.log( "multisig:", multisig_address );
                    var pubkey = borrowerPubkey;
                    var txid = content.txid;
                    var vout = content.vout;
                    //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                    var prev_tx_hex = content.txhex;
                    //todo: during validation, check if principle is between min and max, inclusive
                    var txid_2 = content.txid_2;
                    var vout_2 = content.vout_2;
                    //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                    var prev_tx_hex_2 = content.txhex_2;
                    //todo: during validation, check if principle is between min and max, inclusive
                    var sats = content.principle;
                    var dollars = await satsToDollars( sats );
                    var usdt_collateral = ( Number( dollars ) * ( content.collateral_for_loan / 100 ) ).toFixed( 2 );
                    var claimed_usdt_collateral = content.usdt_collateral;
                    //halt if the user's usdt collateral amount is different from ours by more than 1%
                    var rounded_amount = Math.round( Math.abs( 1 - ( claimed_usdt_collateral / usdt_collateral ) ) * 100 );
                    if ( rounded_amount > 1 ) {
                        //todo: send back failure message
                        alert( "Error. Claimed collateral amount: " + claimed_usdt_collateral + " Real collateral amount: " + usdt_collateral );
                        return;
                    }
                    var real_btc_price = sessionStorage[ "bitcoin_price" ];
                    var claimed_price = content.btc_price;
                    var rounded_price = Math.round( Math.abs( 1 - ( claimed_price / real_btc_price ) ) * 100 );
                    if ( rounded_price > 1 ) {
                        //todo: send back failure message
                        alert( "Error. Claimed btc price: " + claimed_price + " Real btc price: " + real_btc_price );
                        return;
                    }
                    var btc_price = claimed_price;
                    usdt_collateral = claimed_usdt_collateral;
                    var omni_payload = "6f6d6e690000000000000003" + decimalToHex( usdt_collateral );
                    var from_amount = content.sat_value;
                    var mining_fee = 500;
                    var sender = bitcoinjs.ECPair.fromPublicKey(
                      buffer.Buffer.from( content.btcpubkey, 'hex' ),
                      bitcoinjs.networks.testnet
                    );
                    var redeemscript = "0014" + bitcoinjs.crypto.hash160( sender.publicKey ).toString( 'hex' );
                    //the following psbt is for the stage 1 funder
                    var psbt = new bitcoinjs.Psbt({
                      network: bitcoinjs.networks.testnet,
                    });
                    var data = buffer.Buffer.from( omni_payload, 'hex' );
                    var embed = bitcoinjs.payments.embed({ data: [data] });
                    console.log( "txhex:", prev_tx_hex );
                    psbt.addInput({
                      hash: txid,
                      index: vout,
                      nonWitnessUtxo: buffer.Buffer.from(
                        prev_tx_hex,
                        'hex',
                      ),
                      redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                    });
                    psbt.addInput({
                      hash: txid_2,
                      index: vout_2,
                      nonWitnessUtxo: buffer.Buffer.from(
                        prev_tx_hex_2,
                        'hex',
                      ),
                      redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                    });
                    psbt.addOutput({
                      script: embed.output,
                      value: 0,
                    });
                    psbt.addOutput({
                      address: htlc_address,
                      value: ( from_amount + 2000 ) - mining_fee,
                    });

                    var unsigned_stage_1_funder_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                    var unsigned_stage_1_funder_txid = bitcoinjs.Transaction.fromHex( unsigned_stage_1_funder_rawtx ).getId();
                    console.log( "unsigned stage 1 funder, pre scriptsig:", unsigned_stage_1_funder_rawtx );
                    console.log( "unsigned stage 1 funder, pre scriptsig txid:", unsigned_stage_1_funder_txid );

                    var tx = unsigned_stage_1_funder_rawtx.split( "ffffffff" );
                    var scriptsig = '17160014' + bitcoinjs.crypto.hash160(sender.publicKey).toString('hex');
                    tx[ 0 ] = tx[ 0 ].slice( 0, -2 ) + scriptsig;
                    tx[ 1 ] = tx[ 1 ].slice( 0, -2 ) + scriptsig;
                    tx = tx.join( "ffffffff" );
                    var stage_1_funder_with_scriptsig_rawtx = tx;
                    console.log( "unsigned stage 1 funder with scriptsig:", stage_1_funder_with_scriptsig_rawtx );
                    var stage_1_funder_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( stage_1_funder_with_scriptsig_rawtx ).getId();
                    console.log( "unsigned stage 1 funder with scriptsig txid:", stage_1_funder_with_scriptsig_txid );
                    if ( content.stage_1_funder_txid != stage_1_funder_with_scriptsig_txid ) {
                        //todo: send back failure message
                        alert( "error. Claimed stage 1 funder txid: " + content.stage_1_funder_txid + "Real txid: " + stage_1_funder_with_scriptsig_txid );
                        return;
                    }
                    var unsigned_stage_1_funder_psbt = psbt.toHex();

                    var ecPair = bitcoinjs.ECPair.fromPublicKey( borrowerKeypair.publicKey, bitcoinjs.networks.testnet );
                    var { address } = bitcoinjs.payments.p2sh({ 
                       redeem: bitcoinjs.payments.p2wpkh({ pubkey: ecPair.publicKey, network: bitcoinjs.networks.testnet }), 
                       network: bitcoinjs.networks.testnet 
                    });

                    //var address_to_check = address;
                    var address_to_check = `1HckjUpRGcrrRAtFaaCAUaGjsPx9oYmLaZ`;
                    var data = await postData( `https://api.omniwallet.org/v2/address/addr/`, `addr=${address_to_check}`, "application/x-www-form-urlencoded" );

                    var property_i_seek;
                    try {
                        data = JSON.parse( data );
                    } catch( e ) {}
                    if ( Object.keys( data )[ 0 ] && data[ Object.keys( data )[ 0 ] ][ "balance" ] ) {
                        data[ Object.keys( data )[ 0 ] ][ "balance" ].every( function( possibility ) {
                            if ( Number( possibility[ "id" ] ) == 31 ) {
                                property_i_seek = possibility;
                                return;
                            }
                            return true;
                        });
                    } else {
                        property_i_seek = {}
                        property_i_seek[ "reserved" ] = 0;
                        property_i_seek[ "frozen" ] = 0;
                        property_i_seek[ "pendingneg" ] = 0;
                        property_i_seek[ "value" ] = 111111111111111111;
                    }

                    var balance = ( Number( property_i_seek[ "value" ] ) - Number( property_i_seek[ "reserved" ] ) - Number( property_i_seek[ "frozen" ] ) - Number( property_i_seek[ "pendingneg" ] ) ) / 100000000;

                    var conf = confirm( `Please confirm that your counterparty's address, ${address}, has the right amount of usdt, ${usdt_collateral}` );
                    if ( !conf || ( balance < Number( usdt_collateral ) ) ) {
                        //todo: send back failure message
                        alert( "Error, the borrower does not have enough usdt in his address" );
                        return;
                    }
                    //the following psbt is for the stage 2 funder
                    var vout = 1;
                    var new_from_amount = ( from_amount + 2000 ) - mining_fee;
                    var mining_fee = 500;
                    var to_amount = new_from_amount - mining_fee;
                    var psbt = new bitcoinjs.Psbt({
                      network: bitcoinjs.networks.testnet,
                    });
                    var data = buffer.Buffer.from( omni_payload, 'hex' );
                    var embed = bitcoinjs.payments.embed({ data: [data] });
                    psbt.addInput({
                      hash: stage_1_funder_with_scriptsig_txid,
                      index: vout,
                      sequence: 0xfffffffe,
                      redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex'),
                      witnessScript: p2wsh.redeem.output,
                      witnessUtxo: {
                        script: buffer.Buffer.from('a914' + htlc_hash160sha256.toString('hex') + '87', 'hex'),
                        value: ( from_amount + 2000 ),
                      },
                      nonWitnessUtxo: buffer.Buffer.from(
                        prev_tx_hex,
                        'hex',
                      )
                    });
                    psbt.addOutput({
                      script: embed.output,
                      value: 0,
                    });
                    psbt.addOutput({
                      address: multisig_address,
                      value: to_amount,
                    });
                    var getFinalScripts = ( txindex, input, script ) => {
                      // Step 1: Check to make sure the meaningful locking script matches what you expect.
                      var decompiled = bitcoinjs.script.decompile( script )
                      if ( !decompiled ) {
                        throw new Error( `Can not finalize input #${txindex}` )
                      }

                      // Step 2: Create final scripts
                      var witnessStack = bitcoinjs.payments.p2wsh({
                        redeem: {
                          output: script,
                          input: bitcoinjs.script.compile([
                            input.partialSig[0].signature,
                            input.partialSig[1].signature,
                            buffer.Buffer.from( preimage_for_lender, 'hex' ),
                          ]),
                        }
                      });
                      return {
                        finalScriptWitness: witnessStackToScriptWitness( witnessStack.witness ),
                        finalScriptSig: buffer.Buffer.from('220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex')
                      }
                    }

                    var stage_2_funding_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex();
                    var stage_2_funding_txid = psbt.data.globalMap.unsignedTx.tx.getId();
                    console.log( "unsigned stage 2 funder, no scriptsig:", stage_2_funding_rawtx );
                    console.log( "unsigned stage 2 funder, no scriptsig txid:", stage_2_funding_txid );

                    var stage_2_funder_slice_1 = stage_2_funding_rawtx.slice(0, 82)
                    var stage_2_funder_slice_2 = stage_2_funding_rawtx.slice(84)
                    var scriptsig = '23220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex');
                    var stage_2_funder_with_scriptsig_rawtx = stage_2_funder_slice_1 + scriptsig + stage_2_funder_slice_2;
                    var stage_2_funder_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( stage_2_funder_with_scriptsig_rawtx ).getId();
                    console.log( "unsigned stage 2 funder with scriptsig:", stage_2_funder_with_scriptsig_rawtx );
                    console.log( "unsigned stage 2 funder with scriptsig txid:", stage_2_funder_with_scriptsig_txid );

                    var stage_2_funder_psbt_hex = psbt.toHex();
                    var claimed_stage_2_psbt = bitcoinjs.Psbt.fromHex( content.stage_2_funder_psbt );
                    var claimed_stage_2_psbt_txid = claimed_stage_2_psbt.data.globalMap.unsignedTx.tx.getId();
                    if ( claimed_stage_2_psbt_txid != stage_2_funder_with_scriptsig_txid ) {
                        claimed_txhex = claimed_stage_2_psbt.data.globalMap.unsignedTx.tx.toHex();
                        var claimed_stage_2_funder_slice_1 = claimed_txhex.slice(0, 82)
                        var claimed_stage_2_funder_slice_2 = claimed_txhex.slice(84)
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex');
                        var claimed_scriptsig_rawtx = claimed_stage_2_funder_slice_1 + scriptsig + claimed_stage_2_funder_slice_2;
                        var claimed_scriptsig_txid = bitcoinjs.Transaction.fromHex( claimed_scriptsig_rawtx ).getId();
                        if ( claimed_scriptsig_txid != stage_2_funder_with_scriptsig_txid ) {
                            //todo: send back failure message
                            console.log( "the other party's stage 2 funder:", claimed_scriptsig_rawtx );
                            console.log( "and psbt:", claimed_stage_2_psbt.toHex() );
                            console.log( "my stage 2 funder:", stage_2_funder_with_scriptsig_rawtx );
                            console.log( "and psbt:", stage_2_funder_psbt_hex );
                            alert( "Error. Claimed stage 2 txid: " + claimed_stage_2_psbt_txid + "Real stage 2 txid: " + stage_2_funder_with_scriptsig_txid );
                            return;
                        }
                    }
                    claimed_stage_2_psbt.signInput( 0, lenderKeypair );
                    console.log( "stage_2_funder_fully_signed_psbt:", claimed_stage_2_psbt.toHex() );
                    //validate the borrower's signature
                    claimed_stage_2_psbt.validateSignaturesOfInput( 0 );
                    claimed_stage_2_psbt.finalizeInput( 0, getFinalScripts );
                    console.log( "stage_2_funder_fully_signed_tx:", claimed_stage_2_psbt.extractTransaction().toHex() );
                    //initialize the penalty transaction
                    var p2ms = make2of2MultisigOutputScript( borrowerPubkey, lenderPubkey );
                    var multisig_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( p2ms.output ).toString( 'hex' ), 'hex' ) );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: p2ms, network: bitcoinjs.networks.testnet});
                    var p2wsh_for_multisig = p2wsh;
                    var timelock_for_penalty = blockheight + 25920;
                    var vout_for_penalty = 1;
                    //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                    var prev_tx_hex = claimed_stage_2_psbt.extractTransaction().toHex();
                    var { address } = bitcoinjs.payments.p2sh({ redeem: bitcoinjs.payments.p2wpkh({ pubkey: lenderKeypair.publicKey, network: bitcoinjs.networks.testnet }), network: bitcoinjs.networks.testnet});
                    var lender_address = address;
                    var from_amount = bitcoinjs.Transaction.fromHex( prev_tx_hex ).outs[ 1 ][ "value" ];
                    var mining_fee = 500;

                    var psbt = new bitcoinjs.Psbt({
                      network: bitcoinjs.networks.testnet,
                    });
                    psbt.setLocktime( timelock_for_penalty );
                    var data = buffer.Buffer.from( omni_payload, 'hex' );
                    var embed = bitcoinjs.payments.embed({ data: [data] });
                    psbt.addInput({
                      hash: claimed_stage_2_psbt.extractTransaction().getId(),
                      index: vout_for_penalty,
                      sequence: 0xfffffffe,
                      nonWitnessUtxo: buffer.Buffer.from(
                        prev_tx_hex,
                        'hex',
                      ),
                      witnessScript: p2wsh_for_multisig.redeem.output,
                      redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex'), 'hex'),
                    });
                    psbt.addOutput({
                      script: embed.output,
                      value: 0,
                    });
                    psbt.addOutput({
                      address: lender_address,
                      value: from_amount - mining_fee,
                    });

                    var unsigned_stage_3_penalty_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                    var unsigned_stage_3_penalty_txid = bitcoinjs.Transaction.fromHex( unsigned_stage_3_penalty_rawtx ).getId();
                    console.log( "unsigned stage 3 penalty, pre scriptsig:", unsigned_stage_3_penalty_rawtx );
                    console.log( "unsigned stage 3 penalty, pre scriptsig txid:", unsigned_stage_3_penalty_rawtx );

                    var penalty_slice_1 = unsigned_stage_3_penalty_rawtx.slice(0, 82)
                    var penalty_slice_2 = unsigned_stage_3_penalty_rawtx.slice(84)
                    //var scriptsig = '17160014' + bitcoinjs.crypto.hash160(p2ms.output).toString('hex');
                    var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                    var penalty_with_scriptsig_rawtx = penalty_slice_1 + scriptsig + penalty_slice_2;
                    var penalty_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( penalty_with_scriptsig_rawtx ).getId();
                    console.log( "unsigned penalty with scriptsig:", penalty_with_scriptsig_rawtx );
                    console.log( "unsigned penalty with scriptsig txid:", penalty_with_scriptsig_txid );

                    var penalty_psbt_hex = psbt.toHex();
                    var claimed_penalty_psbt = bitcoinjs.Psbt.fromHex( content.stage_3_penalty_psbt );
                    var claimed_penalty_psbt_txid = claimed_penalty_psbt.data.globalMap.unsignedTx.tx.getId();
                    if ( claimed_penalty_psbt_txid != penalty_with_scriptsig_txid ) {
                        claimed_txhex = claimed_penalty_psbt.data.globalMap.unsignedTx.tx.toHex();
                        var claimed_penalty_slice_1 = claimed_txhex.slice(0, 82)
                        var claimed_penalty_slice_2 = claimed_txhex.slice(84)
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                        var claimed_scriptsig_rawtx = claimed_penalty_slice_1 + scriptsig + claimed_penalty_slice_2;
                        var claimed_scriptsig_txid = bitcoinjs.Transaction.fromHex( claimed_scriptsig_rawtx ).getId();
                        if ( claimed_scriptsig_txid != penalty_with_scriptsig_txid ) {
                            //todo: send back failure message
                            console.log( "the other party's penalty tx:", claimed_scriptsig_rawtx );
                            console.log( "and psbt:", claimed_penalty_psbt.toHex() );
                            console.log( "my penalty tx:", penalty_with_scriptsig_rawtx );
                            console.log( "and psbt:", penalty_psbt_hex );
                            //todo: send back failure message
                            alert( "Error. Claimed penalty txid: " + claimed_penalty_psbt_txid + "Real penalty txid: " + penalty_with_scriptsig_txid );
                            return;
                        }
                    }
                    claimed_penalty_psbt.signInput( 0, lenderKeypair );
                    console.log( "stage_3_penalty_fully_signed_psbt:", claimed_penalty_psbt.toHex() );
                    //validate the borrower's signature
                    claimed_penalty_psbt.validateSignaturesOfInput( 0 );
                    claimed_penalty_psbt.finalizeInput( 0 );
                    console.log( "stage_3_penalty_fully_signed_tx:", claimed_penalty_psbt.extractTransaction().toHex() );
                    console.log( "finalized penalty psbt:", claimed_penalty_psbt.toHex() );
                    //intialize payout transaction
                    var vout_for_payout = 1;
                    //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                    var prev_tx_hex = claimed_stage_2_psbt.extractTransaction().toHex();
                    var { address } = bitcoinjs.payments.p2sh({ redeem: bitcoinjs.payments.p2wpkh({ pubkey: lenderKeypair.publicKey, network: bitcoinjs.networks.testnet }), network: bitcoinjs.networks.testnet});
                    var lender_address = address;
                    var from_amount = bitcoinjs.Transaction.fromHex( prev_tx_hex ).outs[ 1 ][ "value" ];
                    var mining_fee = 500;
                    var borrowerAddress = content.borrower_address;

                    var psbt = new bitcoinjs.Psbt({
                      network: bitcoinjs.networks.testnet,
                    });
                    var data = buffer.Buffer.from( omni_payload, 'hex' );
                    var embed = bitcoinjs.payments.embed({ data: [data] });
                    psbt.addInput({
                      hash: claimed_stage_2_psbt.extractTransaction().getId(),
                      index: vout_for_payout,
                      sequence: 0xabababab,
                      nonWitnessUtxo: buffer.Buffer.from(
                        prev_tx_hex,
                        'hex',
                      ),
                      witnessScript: p2wsh_for_multisig.redeem.output,
                      redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex'), 'hex'),
                      sighashType: bitcoinjs.Transaction.SIGHASH_ANYONECANPAY | bitcoinjs.Transaction.SIGHASH_ALL,
                    });
                    psbt.addOutput({
                      script: embed.output,
                      value: 0,
                    });
                    psbt.addOutput({
                      address: lender_address,
                      value: Math.floor( ( ( usdt_collateral / 2 ) / btc_price ) * 100000000 ),
                    });
                    psbt.addOutput({
                      address: borrowerAddress,
                      value: Math.floor( ( from_amount - mining_fee ) / 2 ),
                    });
                    psbt.addOutput({
                      address: borrowerAddress,
                      value: Math.floor( ( from_amount - mining_fee ) / 2 ),
                    });

                    var unsigned_payout_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                    var unsigned_payout_txid = bitcoinjs.Transaction.fromHex( unsigned_payout_rawtx ).getId();
                    console.log( "unsigned payout, pre scriptsig:", unsigned_payout_rawtx );
                    console.log( "unsigned payout, pre scriptsig txid:", unsigned_payout_txid );

                    var payout_slice_1 = unsigned_payout_rawtx.slice(0, 82)
                    var payout_slice_2 = unsigned_payout_rawtx.slice(84)
                    //var scriptsig = '17160014' + bitcoinjs.crypto.hash160(p2ms.output).toString('hex');
                    var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                    var payout_with_scriptsig_rawtx = payout_slice_1 + scriptsig + payout_slice_2;
                    var payout_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( payout_with_scriptsig_rawtx ).getId();
                    console.log( "unsigned payout with scriptsig:", payout_with_scriptsig_rawtx );
                    console.log( "unsigned payout with scriptsig txid:", payout_with_scriptsig_txid );

                    var payout_psbt_hex = psbt.toHex();
                    var claimed_payout_psbt = bitcoinjs.Psbt.fromHex( content.stage_3_payout_psbt );
                    var claimed_payout_psbt_txid = claimed_payout_psbt.data.globalMap.unsignedTx.tx.getId();
                    if ( claimed_payout_psbt_txid != payout_with_scriptsig_txid ) {
                        claimed_txhex = claimed_payout_psbt.data.globalMap.unsignedTx.tx.toHex();
                        var claimed_payout_slice_1 = claimed_txhex.slice(0, 82)
                        var claimed_payout_slice_2 = claimed_txhex.slice(84)
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                        var claimed_scriptsig_rawtx = claimed_payout_slice_1 + scriptsig + claimed_payout_slice_2;
                        var claimed_scriptsig_txid = bitcoinjs.Transaction.fromHex( claimed_scriptsig_rawtx ).getId();
                        if ( claimed_scriptsig_txid != payout_with_scriptsig_txid ) {
                            //todo: send back failure message
                            console.log( "the other party's payout tx:", claimed_scriptsig_rawtx );
                            console.log( "and psbt:", claimed_payout_psbt.toHex() );
                            console.log( "my payout tx:", payout_with_scriptsig_rawtx );
                            console.log( "and psbt:", payout_psbt_hex );
                            //todo: send back failure message
                            alert( "Error. Claimed payout txid: " + claimed_payout_psbt_txid + "Real payout txid: " + payout_with_scriptsig_txid );
                            return;
                        }
                    }
                    claimed_payout_psbt.signInput( 0, lenderKeypair, [bitcoinjs.Transaction.SIGHASH_ANYONECANPAY | bitcoinjs.Transaction.SIGHASH_ALL] );
                    console.log( "fully_signed_payout_psbt:", claimed_payout_psbt.toHex() );
                    //validate the borrower's signature
                    claimed_payout_psbt.validateSignaturesOfInput( 0 );
                    claimed_payout_psbt.finalizeInput( 0 );
                    console.log( "nearly finalized payout psbt (except for its unfunded output):", claimed_payout_psbt.toHex() );
                    //prepare second htlc with roles reversed
                    var timelock = blockheight + 20;
                    console.log( "inputs to witness script: borrowerPubkey:", borrowerPubkey, "lenderPubkey:", lenderPubkey, "pmthash:", pmthash, "timelock:", timelock );
                    var witness_script = generateHtlcWithLenderTimelocked( lenderPubkey, borrowerPubkey, pmthash, timelock );
                    var htlc_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( witness_script ).toString( 'hex' ), 'hex' ) );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witness_script, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                    var p2sh = bitcoinjs.payments.p2sh({redeem: p2wsh, network: bitcoinjs.networks.testnet});
                    var htlc_address = p2sh.address;
                    console.log( "htlc address:", htlc_address );
                    //return here -- lender
                    var note = {};
                    note[ "signed_penalty_psbt" ] = claimed_penalty_psbt.toHex();
                    note[ "signed_payout_psbt" ] = claimed_payout_psbt.toHex();
                    note = JSON.stringify( note );
                    var encryptedNote = encrypt( privKey, event.pubkey, note );
                    var offerEvent = {
                        content: encryptedNote,
                        created_at: Math.floor(Date.now() / 1000),
                        kind: 10004,
                        tags: [["p", event.pubkey]],
                        pubkey: pubKey,
                    };
                    var signedOffer = await getSignedEvent(offerEvent, privKey);
                    socket.send(JSON.stringify(['EVENT', signedOffer]));
                }
                if ( event.kind != 10062 ) return;
                if ( $_GET[ "offer" ] && event.pubkey != $_GET[ "offer" ] ) return;
                 var content = JSON.parse( event[ "content" ] );
                 var div = document.createElement( 'div' );
                 var min_to_lend = content.min_to_lend;
                 var max_to_lend = content.max_to_lend;
                 if ( min_to_lend > 100000 ) {
                     min_to_lend = satsToBitcoin( min_to_lend ) + " btc";
                 } else {
                     min_to_lend = min_to_lend.toLocaleString() + " sats";
                 }
                 if ( max_to_lend > 100000 ) {
                     max_to_lend = satsToBitcoin( max_to_lend ) + " btc";
                 } else {
                     max_to_lend = max_to_lend.toLocaleString() + " sats";
                 }
                 if ( $( `div[ data-pubkey="${event.pubkey}" ]` ) ) $( `div[ data-pubkey="${event.pubkey}" ]` ).remove();
                 div.innerHTML = `<div class="offer" data-pubkey="${event.pubkey}" data-btckey="${content.btcpubkey}" data-pmthash="${content.payment_hash}">
                    <div>You will get: <span><span class="min" data-minval="${content.min_to_lend}">${min_to_lend}</span> - <span class="max" data-maxval="${content.max_to_lend}">${max_to_lend}</span></span></div>
                    <div>You must pay: <span>principle plus ${content.fee_to_borrow}%</span></div>
                    <div>Collateral: <span>${content.collateral_for_loan}% principle in omni usdt</span></div>
                    <div>Loan duration: <span>${content.duration_of_loan} months</span></div>
                    <div><button class="accept_offer">Accept offer</button></div>
                    <div class="fill_in_details">
                        <p>
                            Enter how many sats you want to borrow (use sats and no decimal points)
                        </p>
                        <p>
                            <input type="number" step="1" class="enter_amount">
                        </p>
                        <p>
                            Enter a bitcoin address where you want to receive the money
                        </p>
                        <p>
                            <input class="enter_address">
                        </p>
                        <p>
                            <button class="finalize_acceptance">Submit</button>
                        </p>
                    </div>
                </div>`;
                $( '.orderbook' ).append( div );
                $( `div[ data-pubkey="${event.pubkey}" ] .accept_offer` ).onclick = function() {
                    var ecPair = bitcoinjs.ECPair.fromPublicKey( myBTCKey, bitcoinjs.networks.testnet );
                    var { address } = bitcoinjs.payments.p2sh({ 
                       redeem: bitcoinjs.payments.p2wpkh({ pubkey: ecPair.publicKey, network: bitcoinjs.networks.testnet }), 
                       network: bitcoinjs.networks.testnet 
                    });
                    $( `div[ data-pubkey="${event.pubkey}" ] .fill_in_details` ).style.display = "block";
                    var maxval = $( `div[ data-pubkey="${event.pubkey}" ] .max` ).getAttribute( "data-maxval" )
                    var minval = $( `div[ data-pubkey="${event.pubkey}" ] .min` ).getAttribute( "data-minval" )
                    $( `div[ data-pubkey="${event.pubkey}" ] .enter_amount` ).value = maxval;
                    $( `div[ data-pubkey="${event.pubkey}" ] .enter_amount` ).max = maxval;
                    $( `div[ data-pubkey="${event.pubkey}" ] .enter_amount` ).min = minval;
                    $( `div[ data-pubkey="${event.pubkey}" ] .finalize_acceptance` ).onclick = async function() {
                        var borrowerAddress = $( `div[ data-pubkey="${event.pubkey}" ] .enter_address` ).value;
                        var sats = $( `div[ data-pubkey="${event.pubkey}" ] .enter_amount` ).value;
                        var dollars = await satsToDollars( sats );
                        var usdt_collateral = ( Number( dollars ) * ( content.collateral_for_loan / 100 ) ).toFixed( 2 );
                        if ( usdt_collateral > sessionStorage[ "usdt_balance" ] ) {
                            alert( `You do not have enough usdt to post collateral for this loan. It requires ${usdt_collateral} usdt and you only have ${$( '.usdt_balance' ).innerText} usdt. Please add more usdt and try again.` );
                            return;
                        }
                        var feerate = await getMinFeeRate();
                        var usdt_privkey = getPrivkeyHexFromPath( localStorage[ "backup_words" ], 2, 0 );
                        var usdt_address = getNestedSegwitAddressFromPrivkeyHex( usdt_privkey );
                        var usdt_txid = sendUSDT( usdt_collateral, address, feerate, usdt_address, true, true );
                        // var html = `Send precisely ${usdt_collateral} omni usdt to this bitcoin address: ${address}, then send precisely 2000 sats to pay for mining fees, then click Next`;
                        // html += `<p><input class="txid" placeholder="txid of omni tx"></p>`;
                        // html += `<p><input class="vout" placeholder="vout of omni tx"></p>`;
                        // html += `<p><input class="sat_value" placeholder="sat_value of omni tx"></p>`;
                        // html += `<p><input class="txhex" placeholder="txhex of omni tx"></p>`;
                        // html += `<p><input class="txid_2" placeholder="txid of btc tx"></p>`;
                        // html += `<p><input class="vout_2" placeholder="vout of btc tx"></p>`;
                        // html += `<p><input class="txhex_2" placeholder="txhex of btc tx"></p>`;
                        // html += `<p><button class="start_borrowing" data-pubkey=${event.pubkey}>Next</button></p>`;
                        var principle = Number( $( `div[ data-pubkey="${event.pubkey}" ] .enter_amount` ).value );
                        //$( `div[ data-pubkey="${event.pubkey}" ] .fill_in_details` ).innerHTML = html;
                        //$( `div[ data-pubkey="${event.pubkey}" ] .start_borrowing` ).onclick = async function() {
                        var btc_price = sessionStorage[ "bitcoin_price" ];
                        var txid = usdt_txid;
                        var vout = 4;
                        var sat_value = 546;
                        //var txhex = $( `div[ data-pubkey="${event.pubkey}" ] .txhex` ).value;
                        var txhex = await getData( `https://mempool.space/testnet/api/tx/${usdt_txid}/hex` );
                        var txid_2 = usdt_txid;
                        var vout_2 = 5;
                        var txhex_2 = txhex;
                        var borrowerKeypair = myKeyPair;
                        var borrowerPubkey = borrowerKeypair.publicKey.toString( "hex" );
                        var lenderKeypair = bitcoinjs.ECPair.fromPublicKey( Buffer.from( content.btcpubkey, "hex" ) );
                        var lenderPubkey = lenderKeypair.publicKey.toString( "hex" );
                        var pmthash = content.payment_hash;
                        //var blockheight = await getBlockheight();
                        var blockheight = prompt( "Enter blockheight" );
                        blockheight = Number( blockheight );
                        var timelock = blockheight + 10;
                        console.log( "inputs to witness script: borrowerPubkey:", borrowerPubkey, "lenderPubkey:", lenderPubkey, "pmthash:", pmthash, "timelock:", timelock );
                        var witness_script = generateHtlcWithBorrowerTimelocked( borrowerPubkey, lenderPubkey, pmthash, timelock );
                        var htlc_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( witness_script ).toString( 'hex' ), 'hex' ) );
                        var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witness_script, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var p2sh = bitcoinjs.payments.p2sh({redeem: p2wsh, network: bitcoinjs.networks.testnet});
                        var htlc_address = p2sh.address;
                        console.log( "htlc address:", htlc_address );
                        var p2ms = make2of2MultisigOutputScript( borrowerPubkey, lenderPubkey );
                        var multisig_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( p2ms.output ).toString( 'hex' ), 'hex' ) );
                        var p2wsh = bitcoinjs.payments.p2wsh({redeem: p2ms, network: bitcoinjs.networks.testnet});
                        var p2wsh_for_multisig = p2wsh;
                        var p2sh = bitcoinjs.payments.p2sh({redeem: p2wsh, network: bitcoinjs.networks.testnet});
                        var multisig_address = p2sh.address;
                        console.log( "multisig:", multisig_address );
                        var privkey = myKeyPair.privateKey.toString( "hex" );
                        //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                        console.log( "txhex:", txhex );
                        var prev_tx_hex = txhex;
                        var prev_tx_hex_2 = txhex_2;
                        var omni_payload = "6f6d6e690000000000000003" + decimalToHex( usdt_collateral );
                        var from_amount = sat_value;
                        //todo: get a fee estimate from mempool.space
                        var mining_fee = 500;

                        var sender = bitcoinjs.ECPair.fromPrivateKey(
                          buffer.Buffer.from( privkey, 'hex' ),
                          bitcoinjs.networks.testnet
                        );
                        var redeemscript = "0014" + bitcoinjs.crypto.hash160( sender.publicKey ).toString( 'hex' );
                        var psbt = new bitcoinjs.Psbt({
                          network: bitcoinjs.networks.testnet,
                        });
                        var data = buffer.Buffer.from( omni_payload, 'hex' );
                        var embed = bitcoinjs.payments.embed({ data: [data] });
                        psbt.addInput({
                          hash: txid,
                          index: vout,
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex,
                            'hex',
                          ),
                          redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                        });
                        psbt.addInput({
                          hash: txid_2,
                          index: vout_2,
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex_2,
                            'hex',
                          ),
                          redeemScript: buffer.Buffer.from( redeemscript, "hex" ),
                        });
                        psbt.addOutput({
                          script: embed.output,
                          value: 0,
                        });
                        psbt.addOutput({
                          address: htlc_address,
                          value: ( from_amount + 2000 ) - mining_fee,
                        });

                        var unsigned_stage_1_funder_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                        var unsigned_stage_1_funder_txid = bitcoinjs.Transaction.fromHex( unsigned_stage_1_funder_rawtx ).getId();
                        console.log( "unsigned stage 1 funder, pre scriptsig:", unsigned_stage_1_funder_rawtx );
                        console.log( "unsigned stage 1 funder, pre scriptsig txid:", unsigned_stage_1_funder_txid );

                        var tx = unsigned_stage_1_funder_rawtx.split( "ffffffff" );
                        var scriptsig = '17160014' + bitcoinjs.crypto.hash160(sender.publicKey).toString('hex');
                        tx[ 0 ] = tx[ 0 ].slice( 0, -2 ) + scriptsig;
                        tx[ 1 ] = tx[ 1 ].slice( 0, -2 ) + scriptsig;
                        tx = tx.join( "ffffffff" );
                        var stage_1_funder_with_scriptsig_rawtx = tx;
                        console.log( "unsigned stage 1 funder with scriptsig:", stage_1_funder_with_scriptsig_rawtx );
                        var stage_1_funder_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( stage_1_funder_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned stage 1 funder with scriptsig txid:", stage_1_funder_with_scriptsig_txid );

                        psbt.signInput( 0, sender );
                        psbt.signInput( 1, sender );
                        psbt.finalizeInput( 0 );
                        psbt.finalizeInput( 1 );

                        //await waitSomeSeconds( 2 );

                        var stage_1_funder_signed_tx = psbt.extractTransaction().toHex();
                        var stage_1_funder_signed_txid = psbt.extractTransaction().getId();
                        console.log( "signed stage 1 funder:", stage_1_funder_signed_tx );
                        console.log( "signed stage 1 funder txid:", stage_1_funder_signed_txid );

                        //here I start preparing the stage 1 abort tx
                        var usdt_holder_address = "2MsTF8bHN88yUapJn3pMWn9aZU3LAJqcYBm";
                        var new_from_amount = ( from_amount + 2000 ) - mining_fee;
                        var mining_fee = 500;
                        var to_amount = new_from_amount - mining_fee;
                        var witness_script = generateHtlcWithBorrowerTimelocked( borrowerPubkey, lenderPubkey, pmthash, timelock );
                        var htlc_hash160sha256 = bitcoinjs.crypto.hash160( buffer.Buffer.from( '0020' + bitcoinjs.crypto.sha256( witness_script ).toString( 'hex' ), 'hex' ) );
                        var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witness_script, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var borrower_original_pubkey___not_the_same_as_his_htlc_pubkey = borrowerPubkey.toString( "hex" );
                        var ecPair = bitcoinjs.ECPair.fromPublicKey( buffer.Buffer.from( borrower_original_pubkey___not_the_same_as_his_htlc_pubkey, 'hex' ), bitcoinjs.networks.testnet );
                        var { output } = bitcoinjs.payments.p2sh({ redeem: bitcoinjs.payments.p2wpkh({ pubkey: ecPair.publicKey, network: bitcoinjs.networks.testnet }), network: bitcoinjs.networks.testnet});
                        var tx = unsigned_stage_1_funder_rawtx.split( "ffffffff" );
                        var scriptsig = '17160014' + bitcoinjs.crypto.hash160(sender.publicKey).toString('hex');
                        tx[ 0 ] = tx[ 0 ].slice( 0, -2 ) + scriptsig;
                        tx[ 1 ] = tx[ 1 ].slice( 0, -2 ) + scriptsig;
                        tx = tx.join( "ffffffff" );
                        var stage_1_funder_with_scriptsig_rawtx = tx;
                        console.log( "unsigned stage 1 funder with scriptsig (double-checking because now I'm preparing the abort tx and need the scriptsig to match what it was before):", stage_1_funder_with_scriptsig_rawtx );
                        var stage_1_funder_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( stage_1_funder_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned stage 1 funder with scriptsig txid:", stage_1_funder_with_scriptsig_txid );
                        var vout_for_abort_tx_and_stage_2_funder = 1;
                        var prev_tx_hex = stage_1_funder_with_scriptsig_rawtx;

                        var psbt = new bitcoinjs.Psbt({
                          network: bitcoinjs.networks.testnet,
                        });
                        var data = buffer.Buffer.from( omni_payload, 'hex' );
                        var embed = bitcoinjs.payments.embed({ data: [data] });
                        psbt.addInput({
                          hash: stage_1_funder_with_scriptsig_txid,
                          index: vout_for_abort_tx_and_stage_2_funder,
                          sequence: 0xfffffffe,
                          redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex'),
                          witnessScript: p2wsh.redeem.output,
                          witnessUtxo: {
                            script: buffer.Buffer.from('a914' + htlc_hash160sha256.toString('hex') + '87', 'hex'),
                            value: new_from_amount,
                          },
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex,
                            'hex',
                          )
                        });
                        psbt.addOutput({
                          script: embed.output,
                          value: 0,
                        });
                        psbt.addOutput({
                          address: usdt_holder_address,
                          value: to_amount,
                        });
                        psbt.setLocktime( timelock );
                        var getFinalScripts = ( txindex, input, script ) => {
                          // Step 1: Check to make sure the meaningful locking script matches what you expect.
                          var decompiled = bitcoinjs.script.decompile( script )
                          if ( !decompiled ) {
                            throw new Error( `Can not finalize input #${txindex}` )
                          }

                          // Step 2: Create final scripts
                          var witnessStack = bitcoinjs.payments.p2wsh({
                            redeem: {
                              output: script,
                              input: bitcoinjs.script.compile([
                                input.partialSig[0].signature,
                                buffer.Buffer.from( "", 'hex' ),
                              ]),
                            }
                          });
                          return {
                            finalScriptWitness: witnessStackToScriptWitness( witnessStack.witness ),
                            finalScriptSig: buffer.Buffer.from('220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex')
                          }
                        }

                        var stage_1_abort_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex();
                        var stage_1_abort_txid = psbt.data.globalMap.unsignedTx.tx.getId();
                        console.log( "unsigned aborter, no scriptsig:", stage_1_abort_rawtx );
                        console.log( "unsigned aborter, no scriptsig txid:", stage_1_abort_txid );
                        var aborter_slice_1 = stage_1_abort_rawtx.slice(0, 82)
                        var aborter_slice_2 = stage_1_abort_rawtx.slice(84)
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex');
                        var aborter_with_scriptsig_rawtx = aborter_slice_1 + scriptsig + aborter_slice_2;
                        var aborter_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( aborter_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned aborter with scriptsig:", aborter_with_scriptsig_rawtx );
                        console.log( "unsigned aborter with scriptsig txid:", aborter_with_scriptsig_txid );
                        psbt.signInput( 0, borrowerKeypair );
                        psbt.finalizeInput( 0, getFinalScripts );
                        //await waitSomeSeconds( 2 );
                        var stage_1_abort_signed_tx = psbt.extractTransaction().toHex();
                        var stage_1_abort_signed_txid = psbt.extractTransaction().getId();
                        console.log( "signed aborter:", stage_1_abort_signed_tx );
                        console.log( "signed aborter txid:", stage_1_abort_signed_txid );
                        var aborter_psbt = psbt.toHex();
                        var signed_stage_1_funder_psbt = psbt.toHex();
                        //the following psbt is for the stage_2_funder
                        var psbt = new bitcoinjs.Psbt({
                          network: bitcoinjs.networks.testnet,
                        });
                        var data = buffer.Buffer.from( omni_payload, 'hex' );
                        var embed = bitcoinjs.payments.embed({ data: [data] });
                        psbt.addInput({
                          hash: stage_1_funder_with_scriptsig_txid,
                          index: vout_for_abort_tx_and_stage_2_funder,
                          sequence: 0xfffffffe,
                          redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex'),
                          witnessScript: p2wsh.redeem.output,
                          witnessUtxo: {
                            script: buffer.Buffer.from('a914' + htlc_hash160sha256.toString('hex') + '87', 'hex'),
                            value: new_from_amount,
                          },
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex,
                            'hex',
                          )
                        });
                        psbt.addOutput({
                          script: embed.output,
                          value: 0,
                        });
                        psbt.addOutput({
                          address: multisig_address,
                          value: to_amount,
                        });
                        var getFinalScripts = ( txindex, input, script ) => {
                          // Step 1: Check to make sure the meaningful locking script matches what you expect.
                          var decompiled = bitcoinjs.script.decompile( script );
                          if ( !decompiled ) {
                            throw new Error( `Yeah I cannot finalize input #${txindex} bro` )
                          }

                          // Step 2: Create final scripts
                          var witnessStack = bitcoinjs.payments.p2wsh({
                            redeem: {
                              output: script,
                              input: bitcoinjs.script.compile([
                                input.partialSig[0].signature,
                                input.partialSig[1].signature,
                                buffer.Buffer.from( preimage, 'hex' ),
                              ]),
                            }
                          });
                          return {
                            finalScriptWitness: witnessStackToScriptWitness( witnessStack.witness ),
                            finalScriptSig: buffer.Buffer.from('220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex'), 'hex')
                          }
                        }

                        var stage_2_funding_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex();
                        var stage_2_funding_txid = psbt.data.globalMap.unsignedTx.tx.getId();
                        console.log( "unsigned stage 2 funder, no scriptsig:", stage_2_funding_rawtx );
                        console.log( "unsigned stage 2 funder, no scriptsig txid:", stage_2_funding_txid );

                        var stage_2_funder_slice_1 = stage_2_funding_rawtx.slice(0, 82);
                        var stage_2_funder_slice_2 = stage_2_funding_rawtx.slice(84);
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(witness_script).toString('hex');
                        var stage_2_funder_with_scriptsig_rawtx = stage_2_funder_slice_1 + scriptsig + stage_2_funder_slice_2;
                        var stage_2_funder_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( stage_2_funder_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned stage 2 funder with scriptsig:", stage_2_funder_with_scriptsig_rawtx );
                        console.log( "unsigned stage 2 funder with scriptsig txid:", stage_2_funder_with_scriptsig_txid );

                        psbt.signInput( 0, borrowerKeypair );
                        var stage_2_funder_psbt_hex = psbt.toHex();
                        //the rest of this section should not actually be done yet
                        // psbt.signInput( 0, lenderKeypair );
                        // psbt.finalizeInput( 0, getFinalScripts );
                        // var stage_2_funder_signed_tx = psbt.extractTransaction().toHex();
                        // var stage_2_funder_signed_txid = psbt.extractTransaction().getId();
                        // console.log( "signed stage 2 funder:", stage_2_funder_signed_tx );
                        // console.log( "signed stage 2 funder txid:", stage_2_funder_signed_txid );
                        //initialize penalty transaction
                        var timelock_for_penalty = blockheight + 25920;
                        var vout_for_penalty = 1;
                        //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                        var prev_tx_hex = stage_2_funder_with_scriptsig_rawtx;
                        var { address } = bitcoinjs.payments.p2sh({ redeem: bitcoinjs.payments.p2wpkh({ pubkey: lenderKeypair.publicKey, network: bitcoinjs.networks.testnet }), network: bitcoinjs.networks.testnet});
                        var lender_address = address;
                        var from_amount = bitcoinjs.Transaction.fromHex( prev_tx_hex ).outs[ 1 ][ "value" ];
                        var mining_fee = 500;

                        var psbt = new bitcoinjs.Psbt({
                          network: bitcoinjs.networks.testnet,
                        });
                        psbt.setLocktime( timelock_for_penalty );
                        var data = buffer.Buffer.from( omni_payload, 'hex' );
                        var embed = bitcoinjs.payments.embed({ data: [data] });
                        psbt.addInput({
                          hash: stage_2_funder_with_scriptsig_txid,
                          index: vout_for_penalty,
                          sequence: 0xfffffffe,
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex,
                            'hex',
                          ),
                          witnessScript: p2wsh_for_multisig.redeem.output,
                          redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex'), 'hex'),
                        });
                        psbt.addOutput({
                          script: embed.output,
                          value: 0,
                        });
                        psbt.addOutput({
                          address: lender_address,
                          value: from_amount - mining_fee,
                        });

                        var unsigned_stage_3_penalty_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                        var unsigned_stage_3_penalty_txid = bitcoinjs.Transaction.fromHex( unsigned_stage_3_penalty_rawtx ).getId();
                        console.log( "unsigned stage 3 penalty, pre scriptsig:", unsigned_stage_3_penalty_rawtx );
                        console.log( "unsigned stage 3 penalty, pre scriptsig txid:", unsigned_stage_3_penalty_rawtx );

                        var penalty_slice_1 = unsigned_stage_3_penalty_rawtx.slice(0, 82)
                        var penalty_slice_2 = unsigned_stage_3_penalty_rawtx.slice(84)
                        //var scriptsig = '17160014' + bitcoinjs.crypto.hash160(p2ms.output).toString('hex');
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                        var penalty_with_scriptsig_rawtx = penalty_slice_1 + scriptsig + penalty_slice_2;
                        var penalty_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( penalty_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned penalty with scriptsig:", penalty_with_scriptsig_rawtx );
                        console.log( "unsigned penalty with scriptsig txid:", penalty_with_scriptsig_txid );

                        psbt.signInput( 0, borrowerKeypair );
                        var penalty_psbt_hex = psbt.toHex();
                        //the rest of this section should not actually be done yet
                        // psbt.signInput( 0, lenderKeypair );
                        // psbt.finalizeInput( 0 );

                        // var signed_penalty_tx = psbt.extractTransaction().toHex();
                        // var signed_penalty_txid = psbt.extractTransaction().getId();
                        // console.log( "signed penalty tx:", signed_penalty_tx );
                        // console.log( "signed penalty txid:", signed_penalty_txid );
                        //initialize payout transaction
                        var vout_for_payout = 1;
                        //var prev_tx_hex = await getData( `https://mempool.space/testnet/api/tx/${txid}/hex` );
                        var prev_tx_hex = stage_2_funder_with_scriptsig_rawtx;
                        var { address } = bitcoinjs.payments.p2sh({ redeem: bitcoinjs.payments.p2wpkh({ pubkey: lenderKeypair.publicKey, network: bitcoinjs.networks.testnet }), network: bitcoinjs.networks.testnet});
                        var lender_address = address;
                        var from_amount = bitcoinjs.Transaction.fromHex( prev_tx_hex ).outs[ 1 ][ "value" ];
                        var mining_fee = 500;

                        var psbt = new bitcoinjs.Psbt({
                          network: bitcoinjs.networks.testnet,
                        });
                        var data = buffer.Buffer.from( omni_payload, 'hex' );
                        var embed = bitcoinjs.payments.embed({ data: [data] });
                        psbt.addInput({
                          hash: stage_2_funder_with_scriptsig_txid,
                          index: vout_for_payout,
                          sequence: 0xabababab,
                          nonWitnessUtxo: buffer.Buffer.from(
                            prev_tx_hex,
                            'hex',
                          ),
                          witnessScript: p2wsh_for_multisig.redeem.output,
                          redeemScript: buffer.Buffer.from('0020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex'), 'hex'),
                          sighashType: bitcoinjs.Transaction.SIGHASH_ANYONECANPAY | bitcoinjs.Transaction.SIGHASH_ALL,
                        });
                        psbt.addOutput({
                          script: embed.output,
                          value: 0,
                        });
                        psbt.addOutput({
                          address: lender_address,
                          value: Math.floor( ( ( usdt_collateral / 2 ) / btc_price ) * 100000000 ),
                        });
                        psbt.addOutput({
                          address: borrowerAddress,
                          value: Math.floor( ( from_amount - mining_fee ) / 2 ),
                        });
                        psbt.addOutput({
                          address: borrowerAddress,
                          value: Math.floor( ( from_amount - mining_fee ) / 2 ),
                        });

                        var unsigned_payout_rawtx = psbt.data.globalMap.unsignedTx.tx.toHex()
                        var unsigned_payout_txid = bitcoinjs.Transaction.fromHex( unsigned_payout_rawtx ).getId();
                        console.log( "unsigned payout, pre scriptsig:", unsigned_payout_rawtx );
                        console.log( "unsigned payout, pre scriptsig txid:", unsigned_payout_txid );

                        var payout_slice_1 = unsigned_payout_rawtx.slice(0, 82)
                        var payout_slice_2 = unsigned_payout_rawtx.slice(84)
                        //var scriptsig = '17160014' + bitcoinjs.crypto.hash160(p2ms.output).toString('hex');
                        var scriptsig = '23220020' + bitcoinjs.crypto.sha256(p2ms.output).toString('hex');
                        var payout_with_scriptsig_rawtx = payout_slice_1 + scriptsig + payout_slice_2;
                        var payout_with_scriptsig_txid = bitcoinjs.Transaction.fromHex( payout_with_scriptsig_rawtx ).getId();
                        console.log( "unsigned payout with scriptsig:", payout_with_scriptsig_rawtx );
                        console.log( "unsigned payout with scriptsig txid:", payout_with_scriptsig_txid );

                        psbt.signInput( 0, borrowerKeypair, [bitcoinjs.Transaction.SIGHASH_ANYONECANPAY | bitcoinjs.Transaction.SIGHASH_ALL] );
                        var payout_psbt_hex = psbt.toHex();
                        //the rest of this section should not actually be done yet
                        // psbt.signInput( 0, lenderKeypair );
                        // psbt.finalizeInput( 0 );

                        // var signed_penalty_tx = psbt.extractTransaction().toHex();
                        // var signed_penalty_txid = psbt.extractTransaction().getId();
                        // console.log( "signed penalty tx:", signed_penalty_tx );
                        // console.log( "signed penalty txid:", signed_penalty_txid );
                        //return here -- borrower
                        var note = {};
                        note[ "txid" ] = txid;
                        note[ "vout" ] = vout;
                        note[ "sat_value" ] = sat_value;
                        note[ "txhex" ] = txhex;
                        note[ "txid_2" ] = txid_2;
                        note[ "vout_2" ] = vout_2;
                        note[ "txhex_2" ] = txhex_2;
                        note[ "btcpubkey" ] = myBTCKey.toString( "hex" );
                        note[ "principle" ] = myBTCKey.toString( "hex" );
                        note[ "htlc_address" ] = htlc_address;
                        note[ "usdt_collateral" ] = usdt_collateral;
                        note[ "stage_1_funder_txid" ] = stage_1_funder_with_scriptsig_txid;
                        note[ "stage_2_funder_psbt" ] = stage_2_funder_psbt_hex;
                        note[ "stage_3_penalty_psbt" ] = penalty_psbt_hex;
                        note[ "stage_3_payout_psbt" ] = payout_psbt_hex;
                        note[ "borrower_address" ] = borrowerAddress;
                        note[ "btc_price" ] = btc_price;
                        note = JSON.stringify( note );
                        var encryptedNote = encrypt( privKey, event.pubkey, note );
                        var offerEvent = {
                            content: encryptedNote,
                            created_at: Math.floor(Date.now() / 1000),
                            kind: 10004,
                            tags: [["p", event.pubkey]],
                            pubkey: pubKey,
                        };
                        var signedOffer = await getSignedEvent(offerEvent, privKey);
                        socket.send(JSON.stringify(['EVENT', signedOffer]));
                        //}
                    }
                }
            });
            var timestamp = Math.floor(Date.now() / 1000);
            var timeMinusTen = timestamp - 600;
            var subId = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" ).substring( 0, 20 );
            var filter1 = { kinds: [10062], since: timeMinusTen };
            var filter2 = { "#p": [pubKey] };
            socket.addEventListener('open', async function (e) {
                console.log('connected to ' + relay);
                var subscription = ['REQ', subId, filter1, filter2];
                socket.send(JSON.stringify(subscription));
            });
            async function getSignedEvent(event, privateKey) {
                var eventData = JSON.stringify([
                    0, // Reserved for future use
                    event['pubkey'], // The sender's public key
                    event['created_at'], // Unix timestamp
                    event['kind'], // Message “kind” or type
                    event['tags'], // Tags identify replies/recipients
                    event['content'], // Your note contents
                ]);
                event.id = sha256(eventData).toString('hex');
                event.sig = await schnorr.sign(event.id, privateKey);
                return event;
            }
            $( '.new_offer' ).onclick = function() {
                if ( $( `div[ data-pubkey="${pubKey}" ]` ) ) {
                    var conf = confirm( `You already have an open offer and you can only have one per browser tab. Click ok to continue and replace your current offer with a new one.` );
                    if ( !conf ) return;
                }
                $( '.loan_offer' ).style.display = "block";
                $( '.offer_wizard' ).style.display = "block";
            }
            $( '.lend' ).onclick = function() {
                $( '.pick_borrow_or_lend' ).style.display = "none";
                $( '.loan_offer' ).style.display = "block";
            }
            $( '.submit_loan_offer' ).onclick = async function() {
                var offer_url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + "?offer=" + pubKey;
                $( '.offer_url' ).innerHTML = `Your offer: <a href="${offer_url}">${offer_url}</a>`;
                $( '.offer_url' ).style.display = "block";
                $( '.offer_wizard' ).style.display = "none";
                if ( $( '.privacy_switch' ).checked ) return;
                var utxos = JSON.parse( localStorage[ "utxos" ] );
                var btc_holdings = 0;
                utxos.forEach( function( utxo ) {
                    btc_holdings = btc_holdings + utxo[ "amount" ];
                });
                 var offer = {}
                 offer[ "btcpubkey" ] = myBTCKey.toString( "hex" );
                 offer[ "min_to_lend" ] = Number( $( '.min_to_lend input' ).value );
                 offer[ "max_to_lend" ] = btc_holdings - 5000;
                 offer[ "fee_to_borrow" ] = Number( $( '.fee_to_borrow' ).value );
                 offer[ "collateral_for_loan" ] = Number( $( '.collateral_for_loan' ).value );
                 offer[ "duration_of_loan" ] = Number( $( '.duration_of_loan' ).value.split( " " )[ 0 ] );
                 offer[ "payment_hash" ] = pmthash_for_lender;
                var offerEvent = {
                    content: JSON.stringify(offer),
                    created_at: Math.floor(Date.now() / 1000),
                    kind: 10062,
                    tags: [],
                    pubkey: pubKey,
                };
                var signedOffer = await getSignedEvent(offerEvent, privKey);
                socket.send(JSON.stringify(['EVENT', signedOffer]));
            }
            $( '.view_private_keys' ).onclick = function() {
                $( '.view_private_keys' ).style.display = "none";
                $( '.hide_private_keys' ).style.display = "inline";
                $( '.private_keys' ).style.display = "block";
            }
            $( '.hide_private_keys' ).onclick = function() {
                $( '.hide_private_keys' ).style.display = "none";
                $( '.view_private_keys' ).style.display = "inline";
                $( '.private_keys' ).style.display = "none";
            }
            $( '.deposit_btc' ).onclick = async function() {
                var address = await getFirstUnusedReceiveAddress();
                var html = `<p>Deposit sats here</p><p>${address}</p>`;
                $( '.deposit_and_withdrawal_box' ).innerHTML = html;
                $( '.deposit_and_withdrawal_box' ).style.display = "block";
            }
            $( '.deposit_usdt' ).onclick = async function() {
                var usdt_privkey = getPrivkeyHexFromPath( localStorage[ "backup_words" ], 2, 0 );
                var usdt_address = getNestedSegwitAddressFromPrivkeyHex( usdt_privkey );
                var html = `<p>Deposit usdt here</p><p>${usdt_address}</p>`;
                $( '.deposit_and_withdrawal_box' ).innerHTML = html;
                $( '.deposit_and_withdrawal_box' ).style.display = "block";
            }
            $( '.withdraw_btc' ).onclick = async function() {
                var html = `<p>Recipient's address</p><p><input class="btc_recipients_address"></p>`;
                html += `<p>Amount</p><p><input class="send_btc_amount"></p>`;
                html += `<div class="sliderange"><p>Sats per byte: <span class="sats_per_byte">1</span></p><input class="sats_range" type="range" min="1" max="100" value="1"></div>`;
                html += `<p><button class="finalize_btc_send">Send</button></p>`;
                var fee = await getMinFeeRate();
                $( '.deposit_and_withdrawal_box' ).innerHTML = html;
                var slider = $( ".sats_range" );
                var output = $( ".sats_per_byte" );
                slider.value = fee;
                output.innerHTML = fee;
                slider.oninput = function() {output.innerHTML = this.value;}
                $( '.finalize_btc_send' ).onclick = async function() {
                    console.log( "address:", $( '.btc_recipients_address' ).value );
                    console.log( "amount:", Number( $( '.send_btc_amount' ).value ) );
                    console.log( "sats per byte:", Number( $( '.sats_per_byte' ).innerText ) );
                    simpleSend( Number( $( '.send_btc_amount' ).value ), $( '.btc_recipients_address' ).value, Number( $( '.sats_per_byte' ).innerText ) );
                }
                $( '.deposit_and_withdrawal_box' ).style.display = "block";
            }
            $( '.withdraw_usdt' ).onclick = async function() {
                var html = `<p>Recipient's address</p><p><input class="usdt_recipients_address"></p>`;
                html += `<p>Amount</p><p><input class="send_usdt_amount"></p>`;
                html += `<div class="sliderange"><p>Sats per byte: <span class="sats_per_byte">1</span></p><input class="sats_range" type="range" min="1" max="100" value="1"></div>`;
                html += `<p><button class="finalize_usdt_send">Send</button></p>`;
                var fee = await getMinFeeRate();
                $( '.deposit_and_withdrawal_box' ).innerHTML = html;
                var slider = $( ".sats_range" );
                var output = $( ".sats_per_byte" );
                slider.value = fee;
                output.innerHTML = fee;
                var usdt_privkey = getPrivkeyHexFromPath( localStorage[ "backup_words" ], 2, 0 );
                var usdt_address = getNestedSegwitAddressFromPrivkeyHex( usdt_privkey );
                slider.oninput = function() {output.innerHTML = this.value;}
                $( '.finalize_usdt_send' ).onclick = async function() {
                    console.log( "address:", $( '.usdt_recipients_address' ).value );
                    console.log( "amount:", Number( $( '.send_usdt_amount' ).value ) );
                    console.log( "sats per byte:", Number( $( '.sats_per_byte' ).innerText ) );
                    sendUSDT( Number( $( '.send_usdt_amount' ).value ), $( '.usdt_recipients_address' ).value, Number( $( '.sats_per_byte' ).innerText ), usdt_address );
                }
                $( '.deposit_and_withdrawal_box' ).style.display = "block";
            }
            async function syncUtxosOnLoop() {
                var utxos = JSON.parse( localStorage[ "utxos" ] );
                var current_balance = 0;
                utxos.forEach( function( utxo ) {
                    current_balance = current_balance + utxo[ "amount" ];
                });
                var current_usdt_balance = Number( localStorage[ "usdt_balance" ] );
                if ( current_balance == "loading..." ) current_balance = 0;
                current_balance = Number( current_balance );
                await checkAddresses();
                var utxos = JSON.parse( localStorage[ "utxos" ] );
                var balance = 0;
                utxos.forEach( function( utxo ) {
                    balance = balance + utxo[ "amount" ];
                });
                if ( balance > current_balance ) {
                    if ( $( '.deposit_and_withdrawal_box' ).innerHTML.includes( "Deposit sats here" ) ) {
                        $( '.deposit_and_withdrawal_box' ).style.display = "none";
                    }
                }
                var display_balance = balance;
                var suffix = " sats";
                if ( String( display_balance ).length > 5 ) {
                    display_balance = satsToBitcoin( display_balance );
                    suffix = " btc";
                }
                $( '.btc_balance' ).innerText = display_balance + suffix;
                var usdt_privkey = getPrivkeyHexFromPath( localStorage[ "backup_words" ], 2, 0 );
                var usdt_address = getNestedSegwitAddressFromPrivkeyHex( usdt_privkey );
                //var usdt_address = `1HckjUpRGcrrRAtFaaCAUaGjsPx9oYmLaZ`;
                var usdt_balance = await getUSDTBalance( usdt_address, true );
                if ( isNaN( usdt_balance ) ) usdt_balance = "0.00";
                if ( Number( usdt_balance ) > Number( current_usdt_balance ) ) {
                    if ( $( '.deposit_and_withdrawal_box' ).innerHTML.includes( "Deposit usdt here" ) ) {
                        $( '.deposit_and_withdrawal_box' ).style.display = "none";
                    }
                }
                localStorage[ "usdt_balance" ] = usdt_balance;
                $( '.usdt_balance' ).innerText = Number( localStorage[ "usdt_balance" ] ).toFixed( 2 ) + " usdt";
                var usdt_utxos = await getUsdtUTXOs( usdt_privkey );
                localStorage[ "usdt_utxos" ] = JSON.stringify( usdt_utxos );
                syncUtxosOnLoop();
            }
            localStorage[ "utxos" ] = "[]";
            localStorage[ "usdt_utxos" ] = "[]";
            localStorage.removeItem( "usdt_balance" );
            //prompt for btc utxo here
            console.log( "send btc:", "2MwdKbYGAWPiZwgKFTebbB2QJjfJMQxc2cL" );
            var tx_id = prompt( "Enter a btc txid" );
            var output_number = prompt( "Enter a btc vout" );
            output_number = Number( output_number );
            var amount = prompt( "Enter a btc amount" );
            amount = Number( amount );
            var prev_tx_hex = prompt( "Enter a btc txhex" );
            var privkey = "3da367fd5ca483796aac6d87d53a4b77ad8ce3a5e9edef16a510d7adfac012b9";
            var keypair = bitcoinjs.ECPair.fromPrivateKey( Buffer.from( privkey, "hex" ) );
            var pubkey = keypair.publicKey.toString( "hex" );
            var btc_utxo = {
                "prev_tx_hex":prev_tx_hex,
                "output_number":output_number,
                "amount":amount,
                "tx_id":tx_id,
                "privkey":privkey,
                "pubkey":pubkey
            }
            localStorage[ "utxos" ] = JSON.stringify( [btc_utxo] );
            if ( localStorage[ "utxos" ] ) {
                 var utxos = JSON.parse( localStorage[ "utxos" ] );
             } else {
                 var utxos = [];
             }
            var btc_balance = 0;
            utxos.forEach( function( utxo ) {
                btc_balance = btc_balance + utxo[ "amount" ];
            });
            var display_balance = btc_balance;
            var suffix = " sats";
            if ( String( display_balance ).length > 5 ) {
                display_balance = satsToBitcoin( display_balance );
                suffix = " btc";
            }
            $( '.btc_balance' ).innerText = display_balance + suffix;
            //prompt for usdt utxo and balance here
            console.log( "Send 200 usdt:", "2NEckriYFLUrvkmfBV7WVZMh6TERvtsqHGv" );
            var tx_id = prompt( "Enter a usdt txid" );
            var output_number = prompt( "Enter a usdt vout" );
            output_number = Number( output_number );
            var amount = prompt( "Enter the btc amount" );
            amount = Number( amount );
            var prev_tx_hex = prompt( "Enter a btc txhex" );
            var privkey = getPrivkeyHexFromPath( localStorage[ "backup_words" ], 2, 0 );
            var keypair = bitcoinjs.ECPair.fromPrivateKey( Buffer.from( privkey, "hex" ) );
            var pubkey = keypair.publicKey.toString( "hex" );
            var usdt_utxo = {
                "prev_tx_hex":prev_tx_hex,
                "output_number":output_number,
                "amount":amount,
                "tx_id":tx_id,
                "privkey":privkey,
                "pubkey":pubkey
            }
            localStorage[ "usdt_utxos" ] = JSON.stringify( [usdt_utxo] );
            localStorage[ "usdt_balance" ] = "200";
            if ( localStorage[ "usdt_balance" ] ) {
                 var usdt_balance = Number( localStorage[ "usdt_balance" ] ).toFixed( 2 );
             } else {
                 var usdt_balance = "loading...";
             }
            $( '.usdt_balance' ).innerText = usdt_balance + " usdt";
            //syncUtxosOnLoop();
        </script>
    </body>
</html>
