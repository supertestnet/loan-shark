<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/6502/sha256@main/sha256.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.4"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script src="https://bundle.run/bip39@3.0.4"></script>
        <script src="https://bundle.run/bip32@2.0.6"></script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            input[ type="checkbox" ] {
                line-height: normal;
                width: 1rem;
                height: 1rem;
                font-size: medium;
                border: none;
            }
            .hidden {
                display: none;
            }
            .bold {
                font-weight: bold;
            }
            .bordered {
                border: 1px solid black;
                padding: 1rem;
                margin-bottom: 1rem;
                border-radius: 1rem;
            }
            .offer div {
                margin-bottom: 1rem;
            }
            .offer_wizard {
                display: none;
            }
            .flexy_box {
                display: flex;
                justify-content: space-around;
            }
            .pick_borrow_or_lend {
                display: none;
            }
            .loan_offer {
                display: none;
            }
            .active_contract, .active_contract_lender, .historical_contract, .historical_contract_lender {
                word-break: break-word;
            }
            .black-bg {
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .modal input {
                max-width: 95%;
            }
            .progress_status {
                margin-top: 1rem;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            //temp account wallet 1: job oak ten clever void nuclear screen tooth lumber orbit salad tackle
            //temp account wallet 2: memory owner below select subject common pass sting honey mandate prefer meat
            var backups = {
                backup_words: "",
                utxos: [],
                my_offers: {},
                ready_to_finish: {},
                ready_to_finish_lender: {},
                user_history: {
                    loan_history: {},
                    borrow_history: {},
                }
            }
            var utxos_loaded = false;
            var socket = {}
            var messages_handled = [];
            var my_accepts = {}
            var fresh_change_address, fresh_receive_address;
            var getting_change, getting_receive, getting_utxos;
            var good_socket = false;
            var fee_modified = false;
            var page_loaded = false;
            var displaying_active_contracts_lender = false;
            var displaying_active_contracts_borrower = false;
            sessionStorage.removeItem( "modal_cleared" );
            function getData( url ) {
                return new Promise( async function( resolve, reject ) {
                    function inner_get( url ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "GET", url, true );
                        xhttp.send();
                        return xhttp;
                    }
                    var data = inner_get( url );
                    data.onerror = function( e ) {
                        resolve( "error" );
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve2, reject ) {
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve2( msg );
                                }, 1 );
                            } else {
                                resolve2( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    resolve( returnable );
                });
            }

            var generateWords = twelveortwentyfour => {
                if ( twelveortwentyfour === 24 ) var entropy = 256; else var entropy = 128;    
                return bip39.generateMnemonic( entropy );
            }

            function getPrivkeyHex( backup_words, path, index ) {
                //segwit path is 84'/0'/0'
                //taproot path is 86'/0'/0'
                var seed = bip39.mnemonicToSeedSync( backup_words );
                var node = bip32.fromSeed( seed );
                var path = "m/" + path + "/" + index;
                var root = node;
                var child = root.derivePath( path );
                return child.privateKey.toString( "hex" );
            }

            async function getAddressBalance( address, network ) {
                //TODO: remove the following line when switching to mempool.space
                network = "";
                var nonjson = await getData( "https://mutinynet.com/" + network + "api/address/" + address );
                try {
                    var json = JSON.parse( nonjson );
                } catch( e ) {
                    return 0;
                }
                var fullincome = json[ "chain_stats" ][ "funded_txo_sum" ] + json[ "mempool_stats" ][ "funded_txo_sum" ];
                var fulloutgo = json[ "chain_stats" ][ "spent_txo_sum" ] + json[ "mempool_stats" ][ "spent_txo_sum" ];
                return fullincome - fulloutgo;
            }

            function getCompressedPubkeyHexFromPrivkeyHex( privkeyhex ) {
                return nobleSecp256k1.getPublicKey( privkeyhex, true );
            }

            function getTaprootAddressFromPrivkeyHex( privkeyhex, network ) {
                network = network.replaceAll( "/", "" );
                var pubkey = getCompressedPubkeyHexFromPrivkeyHex( privkeyhex );
                var [ tpubkey ] = tapscript.Tap.getPubKey( pubkey );
                var address = tapscript.Address.p2tr.encode( tpubkey, network );
                return address;
            }

            async function getUTXOs( privkey, network ) {
                var pubkey = getCompressedPubkeyHexFromPrivkeyHex( privkey );
                var address = getTaprootAddressFromPrivkeyHex( privkey, network );
                //TODO: remove the following line when switching to mempool.space
                network = "";
                var esplorautxos = await getData( "https://mutinynet.com/" + network + "api/address/" + address + "/utxo" );
                esplorautxos = JSON.parse( esplorautxos );
                var obj = [];
                esplorautxos.forEach( async ( item, index ) => {
                    var utxo = {}
                    utxo[ "tx_id" ] = item[ "txid" ];
                    utxo[ "output_number" ] = item[ "vout" ];
                    utxo[ "amount" ] = item[ "value" ];
                    utxo[ "privkey" ] = privkey;
                    utxo[ "pubkey" ] = pubkey;
                    utxo[ "address" ] = address;
                    obj.push( utxo );
                });
                return( obj );
            }

            async function getAvailableUtxosFromReceivePath( backup_words, network ) {
                return new Promise( async function( resolve, reject ) {
                    var available_utxos = [];
                    var i1 = 0;
                    var i2 = 0;
                    var gap = 0;
                    var i; for ( i=0; i<100_000; i++ ) {
                        if ( gap > 20 ) break;
                        var path = `86'/0'/0'`;
                        var privkey = getPrivkeyHex( backup_words, path, i1 + i2 );
                        var address = getTaprootAddressFromPrivkeyHex( privkey, network );
                        var once_had_money = await addressOnceHadMoney( address, network );
                        if ( !once_had_money ) {
                            i2 = Number( i2 ) + 1;
                            gap = gap + 1;
                        } else {
                            i1 = Number( i1 ) + 1;
                            var utxos_in_this_address = await getUTXOs( privkey, network );
                            utxos_in_this_address.forEach( utxo => {
                                available_utxos.push( utxo );
                            });
                            gap = 0;
                        }
                    }
                    resolve( available_utxos );
                });
            }

            async function getAvailableUtxosFromChangePath( backup_words, network ) {
                return new Promise( async function( resolve, reject ) {
                    var available_utxos = [];
                    var i1 = 0;
                    var i2 = 0;
                    var gap = 0;
                    var i; for ( i=0; i<100_000; i++ ) {
                        if ( gap > 20 ) break;
                        var path = "86'/0'/1'";
                        var privkey = getPrivkeyHex( backup_words, path, i1 + i2 );
                        var address = getTaprootAddressFromPrivkeyHex( privkey, network );
                        var balance = await getAddressBalance( address, network );
                        var once_had_money = await addressOnceHadMoney( address, network );
                        if ( !once_had_money ) {
                            i2 = Number( i2 ) + 1;
                            gap = gap + 1;
                        } else {
                            i1 = Number( i1 ) + 1;
                            var utxos_in_this_address = await getUTXOs( privkey, network );
                            utxos_in_this_address.forEach( utxo => {
                                available_utxos.push( utxo );
                            });
                            gap = 0;
                        }
                    }
                    resolve( available_utxos );
                });
            }

            async function checkAddresses( backup_words, network ) {
                var available_utxos_1 = await getAvailableUtxosFromReceivePath( backup_words, network );
                var available_utxos_2 = await getAvailableUtxosFromChangePath( backup_words, network );
                available_utxos_2.forEach( function( item ) {
                    available_utxos_1.push( item );
                });
                return available_utxos_1;
            }

            async function getBalanceFromUtxos( utxos ) {
                var balance = 0;
                backups.utxos.forEach( item => balance = balance + Number( item[ "amount" ] ));
                return Number( balance );
            }
            var showBalance = async () => {
                var balance = await getBalanceFromUtxos( backups.utxos );
                if ( balance ) utxos_loaded = true;
                if ( utxos_loaded ) $( '.balance' ).innerText = `${balance} sats`;
            }
            var findUtxos = async () => {
                if ( getting_utxos ) return;
                getting_utxos = true;
                var backup_words = backups[ "backup_words" ];
                backups[ "utxos" ] = await checkAddresses( backup_words, "testnet/" );
                localStorage[ "backups" ] = JSON.stringify( backups );
                utxos_loaded = true;
                getting_utxos = false;
            }
            var makeReceive = async () => {
                if ( getting_receive ) return;
                getting_receive = true;
                var backup_words = backups[ "backup_words" ];
                fresh_receive_address = await getFirstUnusedReceiveAddress( backup_words, "testnet/" );
                getting_receive = false;
            }
            var makeChange = async () => {
                if ( getting_change ) return;
                getting_change = true;
                var backup_words = backups[ "backup_words" ];
                fresh_change_address = await getFirstUnusedChangeAddress( backup_words, "testnet/" );
                getting_change = false;
            }
            var init = async test => {
                if ( !page_loaded ) {
                    await waitABit();
                    return init( "test" );
                }
                if ( !$( '.offer' ) ) $( '.nothing_in_orderbook' ).classList.remove( "hidden" );
                purgeOldContracts();
                displayActiveContracts();
                displayActiveContractsLender();
                var backup_words;
                if ( !backups[ "backup_words" ] && localStorage[ "backups" ] ) backups = JSON.parse( localStorage[ "backups" ] );
                else backup_words = backups[ "backup_words" ];
                if ( !backup_words ) {
                    await waitABit();
                    return init();
                } else {
                    $( '.login' ).click();
                    makeReceive();
                    makeChange();
                    findUtxos();
                    showBalance();
                    displayHistory();
                    checkNostrStatus();
                    addFeeRates();
                    await waitSomeSeconds( 3 );
                    init();
                }
            }

            var waitSomeSeconds = num => {
                var num = num.toString() + "000";
                num = Number( num );
                return new Promise( resolve => setTimeout( resolve, num ) );
            }

            var waitABit = () => {
                return new Promise( resolve => setTimeout( resolve, 500 ) );
            }

            var hider = reveal => {
                $( '.homepage' ).classList.add( "hidden" );
                $( '.wallet' ).classList.add( "hidden" );
                $( '.new_loan_page' ).classList.add( "hidden" );
                $( '.history' ).classList.add( "hidden" );
                $( '.send_page' ).classList.add( "hidden" );
                $( `.${reveal}` ).classList.remove( "hidden" );
            }

            //spendCoins( "tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v", 1000, "testnet/" );
            var spendCoins = async ( destino, amt, sats_per_byte, network ) => {
                var inputs = [];
                var outputs = [];
                var from_amount = 0;
                backups.utxos.forEach( utxo => {
                    var [ tpubkey ] = tapscript.Tap.getPubKey( utxo[ "pubkey" ].substring( 2 ) );
                    from_amount = from_amount + utxo[ "amount" ];
                    var txid = utxo[ "tx_id" ];
                    var vout = utxo[ "output_number" ];
                    var amount = utxo[ "amount" ];
                    inputs.push({
                        txid: txid,
                        vout: vout,
                        prevout: {
                            value: amount,
                            scriptPubKey: [ 'OP_1', tpubkey ]
                        },
                    });
                });
                if ( !from_amount ) return showModal( "You cannot spend without money. Please make a deposit, then try again." );
                var to_amount = amt;
                var there_be_dust = false;
                outputs.push({
                    value: to_amount,
                    scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                });
                if ( to_amount < 546 ) there_be_dust = true;
                if ( there_be_dust ) return showModal( "You cannot send less than 546 sats because that is bitcoin's dust limit. Please try again" );
                if ( from_amount - to_amount < 1 ) return showModal( "You must leave enough to pay a mining fee, please try again" );
                var txsize = 0;
                inputs.forEach( item => txsize = txsize + 64 + 32 + 8 );
                var i; for ( i=0; i<outputs.length; i++ ) {
                    //I calculate that outputs add 37 bytes apiece by
                    //assuming the average scriptpubkey is 33 bytes
                    //and assuming amounts are denoted in 4 bytes
                    txsize = txsize + 37;
                }
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                if ( from_amount - to_amount < mining_fee ) return showModal( `With your chosen fee rate you must leave at least ${mining_fee} sats to pay for mining fees, which means the max you can spend is ${from_amount - mining_fee} sats. Please try again` );
                var backup_words = backups[ "backup_words" ];
                var change_address = await alt_getFirstUnusedChangeAddress( backup_words, network );
                if ( from_amount - ( to_amount + mining_fee ) >= 546 ) {
                    outputs.push({
                        value: from_amount - ( to_amount + mining_fee ),
                        scriptPubKey: tapscript.Address.toScriptPubKey( change_address ),
                    });
                }
                var txdata = tapscript.Tx.create({
                    vin  : inputs,
                    vout : outputs,
                });
                backups.utxos.forEach( ( utxo, index ) => {
                    var [ tseckey ] = tapscript.Tap.getSecKey( utxo[ "privkey" ] );
                    var sig = tapscript.Signer.taproot.sign( tseckey, txdata, index );
                    txdata.vin[ index ].witness = [ sig ];
                });
                var txhex = tapscript.Tx.encode( txdata ).hex;
                var txid = await pushBTCpmt( txhex, "" );
                showModal( `Success! Here is your txid: <a href="https://mutinynet.com/tx/${txid}" target="_blank">https://mutinynet.com/tx/${txid}</a>` );
            }

            async function getThreeFeeRates( network ) {
                //TODO: remove the following line when switching to mempool.space
                network = "";
                var fees = await getData("https://mutinynet.com/" + network + "api/v1/fees/recommended");
                fees = JSON.parse(fees);
                var array = [ fees["minimumFee"], fees["hourFee"], fees["fastestFee"] ];
                return array;
            }

            var getFirstUnusedReceiveAddress = async ( backup_words, network ) => {
                var first_unused_address = "";
                var path = `86'/0'/0'`;
                var i; for ( i=0; i<100_000; i++ ) {
                    var privkey = getPrivkeyHex( backup_words, path, i );
                    var address = getTaprootAddressFromPrivkeyHex( privkey, network );
                    var address_is_used = await addressOnceHadMoney( address, network );
                    if ( !address_is_used ) {
                        first_unused_address = address;
                        break;
                    }
                }
                return first_unused_address;
            }

            var getFirstUnusedChangeAddress = async ( backup_words, network ) => {
                var first_unused_change_address = "";
                var path = `86'/0'/1'`;
                var i; for ( i=0; i<100_000; i++ ) {
                    var privkey = getPrivkeyHex( backup_words, path, i );
                    var address = getTaprootAddressFromPrivkeyHex( privkey, network );
                    var address_is_used = await addressOnceHadMoney( address, network );
                    if ( !address_is_used ) {
                        first_unused_change_address = address;
                        break;
                    }
                }
                return first_unused_change_address;
            }

            var alt_getFirstUnusedReceiveAddress = async ( backup_words, network ) => {
                if ( !fresh_receive_address ) {
                    await waitSomeSeconds( 3 );
                    var addy = await alt_getFirstUnusedReceiveAddress( backup_words, network );
                    return addy;
                }
                var once_had_money = await addressOnceHadMoney( fresh_receive_address, network );
                if ( once_had_money ) {
                    await waitSomeSeconds( 3 );
                    var addy = await alt_getFirstUnusedReceiveAddress( backup_words, network );
                    return addy;
                }
                return fresh_receive_address;
            }

            var alt_getFirstUnusedChangeAddress = async ( backup_words, network ) => {
                if ( !fresh_change_address ) {
                    await waitSomeSeconds( 3 );
                    var addy = await alt_getFirstUnusedChangeAddress( backup_words, network );
                    return addy;
                }
                var once_had_money = await addressOnceHadMoney( fresh_change_address, network );
                if ( once_had_money ) {
                    await waitSomeSeconds( 3 );
                    var addy = await alt_getFirstUnusedChangeAddress( backup_words, network );
                    return addy;
                }
                return fresh_change_address;
            }

            async function addressOnceHadMoney( address, network ) {
                //TODO: remove the following line when switching to mempool.space
                network = "";
                var nonjson = await getData( "https://mutinynet.com/" + network + "api/address/" + address );
                var json = JSON.parse( nonjson );
                if ( json[ "chain_stats" ][ "tx_count" ] > 0 || json[ "mempool_stats" ][ "tx_count" ] > 0 ) return true;
                return false;
            }

            var SHA256 = string_or_uint8array => bytesToHex( sha256( string_or_uint8array ) );
            var bytesToHex = bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            var hexToBytes = hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            
            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }

            var handle30062 = event => {
                var identifier = extractIdentifierFromNostrEvent( event );
                if ( identifier == "no identifier" ) return;
                if ( $( `div[ data-offer_id="${identifier}" ]` ) ) {
                    var offer = $( `div[ data-offer_id="${identifier}" ]` );
                    if ( offer.getElementsByClassName( "fill_in_details" )[ 0 ].classList.contains( "hidden" ) ) offer.remove();
                    else return;
                }
                var lender = event.pubkey;
                if ( !isValidJson( event[ "content" ] ) ) return;
                var content = JSON.parse( event[ "content" ] );
                if ( !( "min_to_lend" in content ) ) return;
                if ( !( "max_to_lend" in content ) ) return;
                if ( !( "fee_to_borrow" in content ) ) return;
                if ( !( "collateral_for_loan" in content ) ) return;
                if ( !( "duration_of_loan" in content ) ) return;
                var div = document.createElement( 'div' );
                var min_to_lend = content.min_to_lend;
                var max_to_lend = content.max_to_lend;
                if ( min_to_lend > 100000 ) {
                    min_to_lend = satsToBitcoin( min_to_lend ) + " btc";
                } else {
                    min_to_lend = min_to_lend.toLocaleString() + " sats";
                }
                if ( max_to_lend > 100000 ) {
                    max_to_lend = satsToBitcoin( max_to_lend ) + " btc";
                } else {
                    max_to_lend = max_to_lend.toLocaleString() + " sats";
                }
                var html = `<div class="offer bordered">
                    <div>You will get: <span><span class="min"></span> - <span class="max"></span></span></div>
                    <div>You must pay: principle plus <span class="fee_to_borrow"></span>%</div>
                    <div>Collateral: <span class="collateral"></span>% principle</div>
                    <div>Loan duration: <span class="duration_of_loan"></span> months</div>`;
                if ( event.pubkey == pubKey ) html += `<div><button class="cancel_offer" onclick="cancelOffer( this.parentElement.parentElement.getAttribute( 'data-offer_id' ) );">Cancel offer</button></div>`;
                if ( event.pubkey == pubKey ) html += `<div><button class="accept_offer" style="display: none;">Accept offer</button></div>`;
                else html += `<div><button class="accept_offer">Accept offer</button></div>`;
                html += `
                    <div class="fill_in_details hidden">
                        <p>
                            Enter how many sats you want to borrow (use sats and no decimal points)
                        </p>
                        <p>
                            <input type="number" step="1" class="enter_amount">
                        </p>
                        <p>
                            <button class="finalize_acceptance">Submit</button>
                        </p>
                    </div>
                </div>`;
                div.innerHTML = html;
                div.getElementsByClassName( "offer" )[ 0 ].setAttribute( "data-timestamp", Math.floor( Date.now() / 1000 ) );
                div.getElementsByClassName( "offer" )[ 0 ].setAttribute( "data-pubkey", lender );
                div.getElementsByClassName( "offer" )[ 0 ].setAttribute( "data-offer_id", identifier );
                div.getElementsByClassName( "min" )[ 0 ].setAttribute( "data-minval", min_to_lend );
                div.getElementsByClassName( "min" )[ 0 ].innerText = min_to_lend;
                div.getElementsByClassName( "max" )[ 0 ].setAttribute( "data-maxval", max_to_lend );
                div.getElementsByClassName( "max" )[ 0 ].innerText = max_to_lend;
                div.getElementsByClassName( "fee_to_borrow" )[ 0 ].innerText = content.fee_to_borrow;
                div.getElementsByClassName( "collateral" )[ 0 ].innerText = content.collateral_for_loan;
                div.getElementsByClassName( "duration_of_loan" )[ 0 ].innerText = content.duration_of_loan;
                var finalize_button = div.getElementsByClassName( "finalize_acceptance" )[ 0 ];
                div.getElementsByClassName( "accept_offer" )[ 0 ].onclick = () => {
                    if ( div.getElementsByClassName( "offer" )[ 0 ].getAttribute( "data-pubkey" ) == pubKey ) return showModal( `You cannot accept your own offer` );
                    div.getElementsByClassName( "fill_in_details" )[ 0 ].classList.remove( "hidden" );
                }
                finalize_button.onclick = async e => {
                    e.target.parentElement.parentElement.classList.add( "hidden" );
                    var principle = Number( div.getElementsByClassName( "enter_amount" )[ 0 ].value );
                    var collateral = principle * Number( ( content.collateral_for_loan / 100 ).toFixed( 2 ) );
                    var btc_holdings = 0;
                    backups.utxos.forEach(  utxo => btc_holdings = btc_holdings + utxo[ "amount" ] );
                    if ( btc_holdings < collateral ) return showModal( `This loan for ${principle} sats requires you to post ${collateral} sats as collateral. You only have ${btc_holdings} sats. Please use the Wallet button to add ${collateral - btc_holdings} sats if you wish to continue` );
                    var utxos_for_this_transaction = [];
                    backups.utxos.forEach( utxo => {
                        utxos_for_this_transaction.push({
                            "value": utxo[ "amount" ],
                            "txid": utxo[ "tx_id" ],
                            "vout": utxo[ "output_number" ],
                            "address": utxo[ "address" ],
                        });
                    });
                    var current_blockheight = await getBlockheight( "" );
                    var backup_words = backups[ "backup_words" ];
                    showProgress( 1, 7, `getting a fresh address` );
                    console.log( `step 1 of 6, getting a fresh address` );
                    var recovery_address = await alt_getFirstUnusedChangeAddress( backup_words, "testnet/" );
                    showProgress( 2, 7, `getting a second fresh address` );
                    console.log( `step 2 of 6, getting a second fresh address` );
                    var principle_address = await alt_getFirstUnusedReceiveAddress( backup_words, "testnet/" );
                    var timelock = content.duration_of_loan * 30 * 144 + current_blockheight;
                    if ( $_GET[ "test_short_loans" ] ) timelock = current_blockheight + Number( $_GET[ "test_short_loans" ] );
                    var script_timelock = convertNumToScript( timelock );
                    var scripts = [
                        [ script_timelock, 'OP_CHECKLOCKTIMEVERIFY', 'OP_DROP', lender, 'OP_CHECKSIG' ],
                        [ 0, lender, 'OP_CHECKSIGADD', pubKey, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ],
                        [ 'OP_RETURN', utxos_for_this_transaction[ 0 ][ "txid" ] + utxos_for_this_transaction[ 0 ][ "vout" ] ],
                    ];
                    var tree = scripts.map(s => tapscript.Tap.encodeScript(s))
                    var pubkey = "ab".repeat( 32 );
                    var [ tpubkey ] = tapscript.Tap.getPubKey(pubkey, { tree });
                    var contract_address = tapscript.Address.p2tr.fromPubKey( tpubkey, 'testnet' );
                    showProgress( 3, 7, `waiting for lender's reply` );
                    console.log( `step 3 of 6, waiting for lender's reply` );
                    var message_for_lender = {
                        msg_type: "accept",
                        msg: {
                            "offer": identifier,
                            "utxos": utxos_for_this_transaction,
                            "principle": principle,
                            "recovery": recovery_address,
                            "principle_address": principle_address,
                            "contract": contract_address,
                            "timelock": timelock,
                        }
                    }
                    var encrypted = encrypt( privKey, lender, JSON.stringify( message_for_lender ) );
                    var offerEvent = {
                        content: encrypted,
                        created_at: Math.floor(Date.now() / 1000),
                        kind: 4,
                        tags: [ [ "p", lender ] ],
                        pubkey: pubKey,
                    };
                    var signedOffer = await getSignedEvent(offerEvent, privKey);
                    socket.send(JSON.stringify(['EVENT', signedOffer]));
                    setTimeout( () => {
                        if ( !sessionStorage[ "lender_replied" ] ) return showModal( `Aborting because the lender did not reply in a timely manner. Please try again` );
                        else sessionStorage.removeItem( "lender_replied" );
                    }, 15000 );
                    message_for_lender[ "original_offer" ] = content;
                    my_accepts[ identifier ] = message_for_lender;
                }
                $( '.nothing_in_orderbook' ).classList.add( "hidden" );
                $( '.orderbook' ).append( div );
            }

            var getXprvFromWords = ( backup_words, pathpart = 0 ) => {
                var hardened = false;
                if ( String( pathpart ).includes( "'" ) ) hardened = true;
                if ( String( pathpart ).includes( "'" ) ) pathpart = Number( pathpart.replaceAll( "'", "" ) );
                var seed = bip39.mnemonicToSeedSync( backup_words );
                var node = bip32.fromSeed( seed );
                var root = node.toBase58();
                var result = bip32.fromBase58( root ).derive( pathpart ).toBase58();
                if ( hardened ) result = bip32.fromBase58( root ).deriveHardened( pathpart ).toBase58();
                return result;
            }

            var getKeypairFromXprv = ( xprv, index ) => {
                //the path is m/0/index
                //to do m/0/0/index just add .derive( 0 ) before .derive( index )
                //to change the first 0, change the .derive( 0 ) in the last line of getXprvFromWords
                var privkey = bip32.fromBase58( xprv ).deriveHardened( 1237 ).deriveHardened( 0 ).derive( 0 ).derive( index ).privateKey.toString( "hex" );
                var pubkey = bip32.fromBase58( xprv ).deriveHardened( 1237 ).deriveHardened( 0 ).derive( 0 ).derive( index ).publicKey.toString( "hex" );
                return [privkey, pubkey];
            }

            function satsToBitcoin( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                return String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 );
            }

            var handle4 = ( content, borrower ) => {
                var is_valid_json = isValidJson( content );
                if ( !is_valid_json ) return;
                var json = JSON.parse( content );
                if ( !( "msg_type" in json ) ) return;
                if ( !( "msg" in json ) ) return;
                if ( json[ "msg_type" ] == "accept" ) return handleAccept( JSON.stringify( json[ "msg" ] ), borrower );
                if ( json[ "msg_type" ] == "finalize" ) return handleFinalize( JSON.stringify( json[ "msg" ] ), borrower );
                else console.log( borrower, content );
            }

            var handleAccept = async ( content, borrower ) => {
                var is_valid_json = isValidJson( content );
                if ( !is_valid_json ) return;
                var json = JSON.parse( content );
                if ( !( "offer" in json ) ) return;
                if ( !( "principle" in json ) ) return;
                if ( !( "recovery" in json ) ) return;
                if ( !( "principle_address" in json ) ) return;
                if ( !( "contract" in json ) ) return;
                if ( !( "timelock" in json ) ) return;
                if ( !( "utxos" in json ) ) return;
                if ( json[ "offer" ].length != 64 || !isValidHex( json[ "offer" ] ) ) return;
                var the_offer = json[ "offer" ];
                if ( !( json[ "offer" ] in backups.my_offers ) ) return;
                if ( typeof json[ "principle" ] != "number" ) return;
                if ( json[ "principle" ] > backups.my_offers[ json[ "offer" ] ][ "max_to_lend" ] ) return;
                if ( json[ "principle" ] < backups.my_offers[ json[ "offer" ] ][ "min_to_lend" ] ) return;
                if ( !isValidAddress( json[ "recovery" ] ) ) return;
                if ( !isValidAddress( json[ "principle_address" ] ) ) return;
                if ( typeof json[ "timelock" ] != "number" ) return;
                var current_blockheight = await getBlockheight( "" );
                if ( json.length ) return;
                if ( json[ "offer" ] != the_offer ) return;
                var expected_timelock = backups.my_offers[ json[ "offer" ] ][ "duration_of_loan" ] * 30 * 144 + current_blockheight;
                if ( $_GET[ "test_short_loans" ] ) expected_timelock = current_blockheight + Number( $_GET[ "test_short_loans" ] );
                if ( Math.abs( expected_timelock - json[ "timelock" ] ) > 2 ) return console.log( `couldn't agree on timelock. I had: ${expected_timelock}. They had: ${json[ "timelock" ]}. Difference was greater than 2 so no deal.` );
                if ( typeof json[ "utxos" ] != "object" ) return;
                if ( !json[ "utxos" ].length ) return;
                var sum_of_values = 0;
                var inputs = [];
                if ( !( "utxos" in json ) || !json[ "utxos" ] ) return;
                var i; for ( i=0; i<json[ "utxos" ].length; i++ ) {
                    var utxo = json[ "utxos" ][ i ];
                    var valid = await isUTXOValid( utxo[ "txid" ], utxo[ "vout" ], utxo[ "value" ], utxo[ "address" ], "" );
                    if ( !valid ) return;
                    sum_of_values = sum_of_values + utxo[ "value" ];
                    inputs.push({
                        txid: utxo[ "txid" ],
                        vout: utxo[ "vout" ],
                        prevout: {
                            value: utxo[ "value" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                        },
                    });
                }
                var collateral_requirement = json[ "principle" ] * Number( ( backups.my_offers[ json[ "offer" ] ][ "collateral_for_loan" ] / 100 ).toFixed( 2 ) );
                if ( sum_of_values < collateral_requirement ) return;
                var borrower_change = sum_of_values - collateral_requirement;
                if ( !isValidAddress( json[ "contract" ] ) ) return;
                var timelock = json[ "timelock" ];
                var script_timelock = convertNumToScript( timelock );
                var scripts = [
                    [ script_timelock, 'OP_CHECKLOCKTIMEVERIFY', 'OP_DROP', pubKey, 'OP_CHECKSIG' ],
                    [ 0, pubKey, 'OP_CHECKSIGADD', borrower, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ],
                    [ 'OP_RETURN', json[ "utxos" ][ 0 ][ "txid" ] + json[ "utxos" ][ 0 ][ "vout" ] ],
                ];
                var tree = scripts.map(s => tapscript.Tap.encodeScript(s));
                var pubkey = "ab".repeat( 32 );
                var script = scripts[ 1 ];
                var target = tapscript.Tap.encodeScript(script);
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                var seizure_script = scripts[ 0 ];
                var seizure_target = tapscript.Tap.encodeScript(seizure_script);
                var [ tpubkey, seizure_cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target: seizure_target });
                var contract_address = tapscript.Address.p2tr.fromPubKey( tpubkey, 'testnet' );
                if ( contract_address != json[ "contract" ] ) return;
                var utxos_for_this_transaction = [];
                backups.utxos.forEach( utxo => {
                    utxos_for_this_transaction.push({
                        "value": utxo[ "amount" ],
                        "txid": utxo[ "tx_id" ],
                        "vout": utxo[ "output_number" ],
                        "address": utxo[ "address" ],
                    });
                });
                var sum_of_values = 0;
                var i; for ( i=0; i<utxos_for_this_transaction.length; i++ ) {
                    var utxo = utxos_for_this_transaction[ i ];
                    inputs.push({
                        txid: utxo[ "txid" ],
                        vout: utxo[ "vout" ],
                        prevout: {
                            value: utxo[ "value" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                        },
                    });
                    sum_of_values = sum_of_values + utxo[ "value" ];
                }
                if ( sum_of_values - json[ "principle" ] != 0 && sum_of_values - json[ "principle" ] < 546 ) return console.log( `Someone tried to make a deal with you but I am aborting. Your utxos are worth ${sum_of_values} sats and the principle is ${collateral_requirement} sats, leaving you with leftover change of ${sum_of_values - json[ "principle" ]} sats, which is less than the dust limit of 546. Add another utxo to resolve this problem.` );
                var lender_change = sum_of_values - json[ "principle" ];
                var outputs = [];
                var txsize = 0;
                inputs.forEach( item => txsize = txsize + 64 + 32 + 8 );
                var num_of_outputs_to_expect = 2;
                if ( lender_change ) num_of_outputs_to_expect = 3;
                var i; for ( i=0; i<num_of_outputs_to_expect; i++ ) {
                    //I calculate that outputs add 37 bytes apiece by
                    //assuming the average scriptpubkey is 33 bytes
                    //and assuming amounts are denoted in 4 bytes
                    txsize = txsize + 37;
                }
                var fee_options = await getThreeFeeRates( "" );
                var sats_per_byte = fee_options[ 1 ];
                sats_per_byte = Number( sats_per_byte );
                if ( !sats_per_byte ) return console.log( "Someone tried to make a deal with you but there was an error getting fee rates. Aborting, please try again." );
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                //this first output (vout 0) puts the collateral in the contract
                outputs.push({
                    value: collateral_requirement,
                    scriptPubKey: tapscript.Address.toScriptPubKey( contract_address ),
                });
                var amount_for_borrower = json[ "principle" ];
                if ( borrower_change ) amount_for_borrower = amount_for_borrower + borrower_change - mining_fee;
                //this second vout (vout 1) gives the principle, and some change if necessary, to the borrower
                if ( !( "principle_address" in json ) ) return console.log( "aborting because the json had no principle address:", json );
                outputs.push({
                    value: amount_for_borrower,
                    scriptPubKey: tapscript.Address.toScriptPubKey( json[ "principle_address" ] ),
                });
                //this optional third vout (vout 2) gives some change, if necessary, to the lender
                if ( lender_change ) {
                    var backup_words = backups[ "backup_words" ];
                    var lender_change_address = await alt_getFirstUnusedChangeAddress( backup_words, "testnet/" );
                    outputs.push({
                        value: lender_change,
                        scriptPubKey: tapscript.Address.toScriptPubKey( lender_change_address ),
                    });
                }
                var txdata = tapscript.Tx.create({
                    vin: inputs,
                    vout: outputs,
                });
                var index_of_my_inputs = txdata[ "vin" ].length - backups.utxos.length;
                var my_sigs = [];
                var num = 0;
                var i; for ( i=index_of_my_inputs; i<txdata[ "vin" ].length; i++ ) {
                    var [ tseckey ] = tapscript.Tap.getSecKey( backups.utxos[ num ][ "privkey" ] );
                    my_sigs.push( tapscript.Signer.taproot.sign( tseckey, txdata, i ).hex );
                    var sighash = await tapscript.Signer.taproot.hash( txdata, i );
                    txdata.vin[ i ].witness = [ my_sigs[ num ] ];
                    num = num + 1;
                }
                var txhex = tapscript.Tx.encode( txdata ).hex;
                var txid = tapscript.Tx.util.getTxid( txhex );
                if ( !( json[ "offer" ] in backups.my_offers ) ) return console.log( `this offer: ${json[ "offer" ]} was not in my offers: ${backups.my_offers}` );
                var repayment_value = Math.round( json[ "principle" ] * Number( `1.${backups.my_offers[ json[ "offer" ] ][ "fee_to_borrow" ]}` ) );
                //each input contributes a 64 byte signature, a 32 byte txid, a 4 byte vout, and 4 extra bytes for padding
                var txsize = 64 + 32 + 8;
                //each output contributes a 33 byte scriptpubkey and a 4 byte value
                txsize = txsize + 37 * 2;
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                if ( !( "recovery" in json ) ) return console.log( "recovery address had no recovery address:", json );
                var repayment_address = await alt_getFirstUnusedReceiveAddress( backup_words, "testnet/" );
                var repayment_txdata = tapscript.Tx.create({
                    vin: [{
                        txid: txid,
                        vout: 0,
                        prevout: {
                            value: collateral_requirement,
                            scriptPubKey: tapscript.Address.toScriptPubKey( contract_address ),
                        },
                    }],
                    vout: [{
                        value: repayment_value,
                        scriptPubKey: tapscript.Address.toScriptPubKey( repayment_address ),
                    },{
                        value: collateral_requirement,
                        scriptPubKey: tapscript.Address.toScriptPubKey( json[ "recovery" ] ),
                    }],
                });
                var sig = tapscript.Signer.taproot.sign( privKey, repayment_txdata, 0, { extension: target, sigflag: 128 | 2 } ).hex;
                repayment_txdata.vin[ 0 ].witness = [ sig, script, cblock ];
                var isValid = await tapscript.Signer.taproot.verify( repayment_txdata, 0, { extension: target, sigflag: 128 | 2, pubkey: pubKey });
                var sighash = await tapscript.Signer.taproot.hash( repayment_txdata, 0, { extension: target, sigflag: 128 | 2 } );
                var isValid = await nobleSecp256k1.schnorr.verify( sig.substring( 0, 128 ), sighash.hex, pubKey );
                if ( !isValid ) return console.log( `Oh no, I had to abort because your signture for the repayment tx was invalid! Ask a developer for help` );
                var seizure_txdata = tapscript.Tx.create({
                    vin: [{
                        txid: txid,
                        vout: 0,
                        prevout: {
                            value: collateral_requirement,
                            scriptPubKey: tapscript.Address.toScriptPubKey( contract_address ),
                        },
                        sequence: 0xfffffffd,
                    }],
                    vout: [{
                        value: collateral_requirement - mining_fee,
                        scriptPubKey: tapscript.Address.toScriptPubKey( repayment_address ),
                    }],
                    locktime: Number( timelock ),
                });
                backups.ready_to_finish_lender[ json[ "offer" ] ] = [ timelock, seizure_txdata[ "vin" ], seizure_target, seizure_script, seizure_cblock, contract_address, json, backups.my_offers[ json[ "offer" ] ], borrower, json[ "offer" ] ];
                backups.user_history[ "loan_history" ][ json[ "offer" ] ] = [ contract_address, json, backups.my_offers[ json[ "offer" ] ] ];
                localStorage[ "backups" ] = JSON.stringify( backups );
                displayHistory();
                var message_for_borrower = {
                    msg_type: "finalize",
                    msg: {
                        "offer": json[ "offer" ],
                        "utxos": utxos_for_this_transaction,
                        "swap_sigs": my_sigs,
                        "repay_sig": sig,
                        "repay_addy": repayment_address,
                    }
                }
                if ( lender_change ) message_for_borrower[ "msg" ][ "lender_change_address" ] = lender_change_address;
                var encrypted = encrypt( privKey, borrower, JSON.stringify( message_for_borrower ) );
                var offerEvent = {
                    content: encrypted,
                    created_at: Math.floor(Date.now() / 1000),
                    kind: 4,
                    tags: [ [ "p", borrower ] ],
                    pubkey: pubKey,
                };
                var signedOffer = await getSignedEvent(offerEvent, privKey);
                socket.send(JSON.stringify(['EVENT', signedOffer]));
            }

            var handleFinalize = async ( content, lender ) => {
                var is_valid_json = isValidJson( content );
                if ( !is_valid_json ) return;
                var json = JSON.parse( content );
                if ( !( "offer" in json ) ) return;
                if ( !( "swap_sigs" in json ) ) return;
                if ( !( "repay_sig" in json ) ) return;
                if ( !( "repay_addy" in json ) ) return;
                if ( !( "utxos" in json ) ) return;
                if ( json[ "offer" ].length != 64 || !isValidHex( json[ "offer" ] ) ) return;
                if ( !( json[ "offer" ] in my_accepts ) ) return;
                var i; for ( i=0; i<json[ "swap_sigs" ].length; i++ ) {
                    if ( !isValidHex( json[ "swap_sigs" ][ i ] ) || json[ "swap_sigs" ][ i ].length != 128 ) return;
                }
                if ( !isValidHex( json[ "repay_sig" ] ) || json[ "repay_sig" ].length != 130 ) return;
                if ( !isValidAddress( json[ "repay_addy" ] ) ) return;
                var inputs = [];
                var sum_of_values = 0;
                var i; for ( i=0; i<my_accepts[ json[ "offer" ] ][ "msg" ][ "utxos" ].length; i++ ) {
                    var utxo = my_accepts[ json[ "offer" ] ][ "msg" ][ "utxos" ][ i ];
                    inputs.push({
                        txid: utxo[ "txid" ],
                        vout: utxo[ "vout" ],
                        prevout: {
                            value: utxo[ "value" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                        },
                    });
                    sum_of_values = sum_of_values + utxo[ "value" ];
                }
                var principle = my_accepts[ json[ "offer" ] ][ "msg" ][ "principle" ];
                var timelock = my_accepts[ json[ "offer" ] ][ "msg" ][ "timelock" ];
                var collateral_requirement = principle * Number( ( my_accepts[ json[ "offer" ] ][ "original_offer" ][ "collateral_for_loan" ] / 100 ).toFixed( 2 ) );
                var borrower_change = sum_of_values - collateral_requirement;
                var sum_of_values = 0;
                if ( !( "utxos" in json ) ) return;
                showProgress( 4, 7, `validating lender's utxos` );
                console.log( `step 4 of 6, validating lender's utxos` );
                sessionStorage[ "lender_replied" ] = true;
                var i; for ( i=0; i<json[ "utxos" ].length; i++ ) {
                    var utxo = json[ "utxos" ][ i ];
                    var valid = await isUTXOValid( utxo[ "txid" ], utxo[ "vout" ], utxo[ "value" ], utxo[ "address" ], "" );
                    if ( !valid ) {
                        return showModal( `Aborting because the lender sent you an invalid utxo. Specifically, he said ${utxo[ "txid" ].substring( 0, 4 ) + "..." + utxo[ "txid" ].substring( utxo[ "txid" ].length - 4 )}:${utxo[ "vout" ]} is in address ${utxo[ "address" ]} with a value of ${utxo[ "value" ]} sats, and it isn't, as you can view <a href="${"https://mutinynet.com/api/address/" + utxo[ "address" ] + "/utxo"}" target="_blank">here</a>` );
                    }
                    sum_of_values = sum_of_values + utxo[ "value" ];
                    inputs.push({
                        txid: utxo[ "txid" ],
                        vout: utxo[ "vout" ],
                        prevout: {
                            value: utxo[ "value" ],
                            scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                        },
                    });
                }
                if ( sum_of_values < principle ) return;
                var lender_change = sum_of_values - principle;
                if ( lender_change && !( "lender_change_address" in json ) ) return;
                if ( lender_change && !isValidAddress( json[ "lender_change_address" ] ) ) return;
                var contract_address = my_accepts[ json[ "offer" ] ][ "msg" ][ "contract" ];
                var principle_address = my_accepts[ json[ "offer" ] ][ "msg" ][ "principle_address" ];
                var lender_change_address = json[ "lender_change_address" ];
                var repayment_address = json[ "repay_addy" ];
                var recovery_address = my_accepts[ json[ "offer" ] ][ "msg" ][ "recovery" ];
                var outputs = [];
                var txsize = 0;
                inputs.forEach( item => txsize = txsize + 64 + 32 + 8 );
                var num_of_outputs_to_expect = 2;
                if ( lender_change ) num_of_outputs_to_expect = 3;
                var i; for ( i=0; i<num_of_outputs_to_expect; i++ ) {
                    //I calculate that outputs add 37 bytes apiece by
                    //assuming the average scriptpubkey is 33 bytes
                    //and assuming amounts are denoted in 4 bytes
                    txsize = txsize + 37;
                }
                showProgress( 5, 7, `validating fee rates` );
                console.log( `step 5 of 6, validating fee rates` );
                var fee_options = await getThreeFeeRates( "" );
                var sats_per_byte = fee_options[ 1 ];
                sats_per_byte = Number( sats_per_byte );
                if ( !sats_per_byte ) return showModal( "There was an error getting fee rates. Aborting, please try again." );
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                //this first output (vout 0) puts the collateral in the contract
                outputs.push({
                    value: collateral_requirement,
                    scriptPubKey: tapscript.Address.toScriptPubKey( contract_address ),
                });
                var amount_for_borrower = principle;
                if ( borrower_change ) amount_for_borrower = amount_for_borrower + borrower_change - mining_fee;
                //this second vout (vout 1) gives the principle, and some change if necessary, to the borrower
                outputs.push({
                    value: amount_for_borrower,
                    scriptPubKey: tapscript.Address.toScriptPubKey( principle_address ),
                });
                //this optional third vout (vout 2) gives some change, if necessary, to the lender
                if ( lender_change ) {
                    outputs.push({
                        value: lender_change,
                        scriptPubKey: tapscript.Address.toScriptPubKey( lender_change_address ),
                    });
                }
                var txdata = tapscript.Tx.create({
                    vin: inputs,
                    vout: outputs,
                });
                var my_sigs = [];
                var i; for ( i=0; i<backups.utxos.length; i++ ) {
                    var [ tseckey ] = tapscript.Tap.getSecKey( backups.utxos[ i ][ "privkey" ] );
                    my_sigs.push( tapscript.Signer.taproot.sign( tseckey, txdata, i ).hex );
                    txdata.vin[ i ].witness = [ my_sigs[ i ] ];
                }
                var swap_sigs = json[ "swap_sigs" ];
                var index_of_lender_inputs = txdata[ "vin" ].length - json[ "utxos" ].length;
                var i; for ( i=index_of_lender_inputs; i<txdata[ "vin" ].length; i++ ) {
                    var isValid = false;
                    var sighash = await tapscript.Signer.taproot.hash( txdata, i );
                    var sig = swap_sigs[ i - backups.utxos.length ];
                    var words = bech32.bech32m.decode( json[ "utxos" ][ i - backups.utxos.length ][ "address" ] ).words;
                    var segwit_version = words[ 0 ];
                    words.splice( 0, 1 );
                    var pubkey = bytesToHex( bech32.bech32m.fromWords( words ) );
                    isValid = await nobleSecp256k1.schnorr.verify( sig, sighash.hex, pubkey );
                    if ( !isValid ) return showModal( `Oh no, one of your counterparty's signtures for the swap transaction was invalid! Aborting` );
                    txdata.vin[ i ].witness = [ swap_sigs[ i - backups.utxos.length ] ];
                    try {
                        var sig = swap_sigs[ i - backups.utxos.length ];
                        var words = bech32.bech32m.decode( json[ "utxos" ][ i - backups.utxos.length ][ "address" ] ).words;
                        var segwit_version = words[ 0 ];
                        words.splice( 0, 1 );
                        var pubkey = bytesToHex( bech32.bech32m.fromWords( words ) );
                        isValid = await nobleSecp256k1.schnorr.verify( sig, sighash.hex, pubkey );
                        if ( !isValid ) return showModal( `Oh no, one of your counterparty's signtures for the swap transaction was invalid! Aborting` );
                        txdata.vin[ i ].witness = [ swap_sigs[ i - backups.utxos.length ] ];
                    } catch( e ) {
                        return showModal( `Oh no, one of your counterparty's signatures for the swap transaction was invalid! Aborting (btw, this is the warning when there was an error in the try/catch block)` );
                    }
                    if ( !isValid ) return showModal( `Oh no, one of your counterparty's signatures for the swap transaction was invalid! Aborting` );
                }
                var txhex = tapscript.Tx.encode( txdata ).hex;
                await pushBTCpmt( txhex, "" );
                showProgress( 6, 7, `watching mempool for your transaction` );
                console.log( `step 6 of 6, watching mempool for your transaction` );
                var txid = tapscript.Tx.util.getTxid( txhex );
                var repayment_value = Math.round( principle * Number( `1.${my_accepts[ json[ "offer" ] ][ "original_offer" ][ "fee_to_borrow" ]}` ) );
                //each input contributes a 64 byte signature, a 32 byte txid, a 4 byte vout, and 4 extra bytes for padding
                var txsize = 64 + 32 + 8;
                //each output contributes a 33 byte scriptpubkey and a 4 byte value
                txsize = txsize + 37 * 2;
                var mining_fee = txsize * sats_per_byte;
                if ( mining_fee < 172 ) mining_fee = 172;
                var repayment_txdata = tapscript.Tx.create({
                    vin: [{
                        txid: txid,
                        vout: 0,
                        prevout: {
                            value: collateral_requirement,
                            scriptPubKey: tapscript.Address.toScriptPubKey( contract_address ),
                        },
                    }],
                    vout: [{
                        value: repayment_value,
                        scriptPubKey: tapscript.Address.toScriptPubKey( repayment_address ),
                    },{
                        value: collateral_requirement,
                        scriptPubKey: tapscript.Address.toScriptPubKey( recovery_address ),
                    }],
                });
                var utxos_for_this_transaction = my_accepts[ json[ "offer" ] ][ "msg" ][ "utxos" ];
                var script_timelock = convertNumToScript( timelock );
                var scripts = [
                    [ script_timelock, 'OP_CHECKLOCKTIMEVERIFY', 'OP_DROP', lender, 'OP_CHECKSIG' ],
                    [ 0, lender, 'OP_CHECKSIGADD', pubKey, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ],
                    [ 'OP_RETURN', utxos_for_this_transaction[ 0 ][ "txid" ] + utxos_for_this_transaction[ 0 ][ "vout" ] ],
                ];
                var tree = scripts.map(s => tapscript.Tap.encodeScript(s));
                var pubkey = "ab".repeat( 32 );
                var script = scripts[ 1 ];
                var target = tapscript.Tap.encodeScript(script);
                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                var sig = tapscript.Signer.taproot.sign( privKey, repayment_txdata, 0, { extension: target } ).hex;
                repayment_txdata.vin[ 0 ].witness = [ sig, script, cblock ];
                var isValid = await tapscript.Signer.taproot.verify( repayment_txdata, 0, { extension: target, pubkey: pubKey });
                if ( !isValid ) return showModal( `Oh no, your signture for the repayment tx was invalid! Ask a developer for help` );
                var lenders_sig = json[ "repay_sig" ];
                var sighash = await tapscript.Signer.taproot.hash( repayment_txdata, 0, { extension: target, sigflag: 128 | 2 } );
                var isValid = await nobleSecp256k1.schnorr.verify( lenders_sig.substring( 0, 128 ), sighash.hex, lender );
                if ( !isValid ) return showModal( `Oh no, your counterparty's signture for the repayment tx was invalid! Aborting` );
                var inputs_and_outputs = [ repayment_txdata[ "vin" ], repayment_txdata[ "vout" ] ];
                if ( !( String( timelock ) in backups.ready_to_finish ) ) backups.ready_to_finish[ String( timelock ) ] = [];
                backups.ready_to_finish[ String( timelock ) ].push( inputs_and_outputs, my_accepts[ json[ "offer" ] ], lender, lenders_sig );
                backups.user_history[ "borrow_history" ][ json[ "offer" ] ] = my_accepts[ json[ "offer" ] ];
                localStorage[ "backups" ] = JSON.stringify( backups );
                displayHistory();
            }

            function isValidJson( content ) {
                if ( !content ) return;
                try {  
                    var json = JSON.parse( content );
                } catch ( e ) {
                    return;
                }
                return true;
            }

            function isValidHex( h ) {
                if ( !h ) return;
                var length = h.length;
                if ( length % 2 ) return;
                try {
                    var a = BigInt( "0x" + h, "hex" );
                } catch( e ) {
                    return;
                }
                var unpadded = a.toString( 16 );
                var padding = [];
                var i; for ( i=0; i<length; i++ ) padding.push( 0 );
                padding = padding.join( "" );
                padding = padding + unpadded.toString();
                padding = padding.slice( -Math.abs( length ) );
                return ( padding === h );
            }

            function isValidAddress( address ) {
                try{
                    return !!tapscript.Address.decode( address ).script;
                } catch( e ) {return;}
                return;
            }

            async function isUTXOValid( txid, vout, value, address, network ) {
                var esplorautxos = await getData( "https://mutinynet.com/" + network + "api/address/" + address + "/utxo" );
                esplorautxos = JSON.parse( esplorautxos );
                var obj = [];
                var is_valid = false;
                esplorautxos.every( async item => {
                    if ( item[ "txid" ] == txid && item[ "vout" ] == vout && item[ "value" ] == value ) return is_valid = true;
                    return true;
                });
                return is_valid;
            }

            async function getBlockheight( network ) {
                var data = await getData( `https://mutinynet.com/${network}api/blocks/tip/height` );
                return Number( data );
            }

            var purgeOldContracts = async () => {
                var now = Math.floor( Date.now() / 1000 );
                var now_minus_ten = now - 600;
                var i; for ( i=0; i<Object.keys( backups.my_offers ).length; i++ ) {
                    var key = Object.keys( backups.my_offers )[ i ];
                    var item = backups.my_offers[ key ];
                    if ( !( "timestamp" in item ) || item[ "timestamp" ] < now_minus_ten ) {
                        var offer = JSON.parse( JSON.stringify( backups.my_offers[ key ] ) );
                        delete backups.my_offers[ key ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                        if ( "private" in offer ) continue;
                        delete offer[ "timestamp" ];
                        var btc_holdings = 0;
                        backups.utxos.forEach(  utxo => btc_holdings = btc_holdings + utxo[ "amount" ] );
                        offer[ "max_to_lend" ] = btc_holdings;
                        var offerEvent = {
                            content: JSON.stringify( offer ),
                            created_at: Math.floor( Date.now() / 1000 ),
                            kind: 30062,
                            tags: [ [ "d", key ] ],
                            pubkey: pubKey,
                        };
                        var signedOffer = await getSignedEvent( offerEvent, privKey );
                        socket.send(JSON.stringify(['EVENT', signedOffer]));
                        offer[ "timestamp" ] = Math.floor( Date.now() / 1000 );
                        backups.my_offers[ key ] = offer;
                        localStorage[ "backups" ] = JSON.stringify( backups );
                    }
                }
                $$( '.offer' ).forEach( item => {
                    if ( Number( item.getAttribute( "data-timestamp" ) ) < now_minus_ten ) item.parentElement.remove();
                });
                Object.keys( backups.ready_to_finish ).forEach( async ( item, index ) => {
                    var contract = backups.ready_to_finish[ item ][ 1 ][ "msg" ][ "contract" ];
                    //check if address sent money
                    var contract_is_fulfilled = await addressOnceSentMoney( contract, "" );
                    if ( contract_is_fulfilled ) {
                        delete backups.ready_to_finish[ item ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                    }
                });
                var current_blockheight = await getBlockheight( "" );
                Object.keys( backups.ready_to_finish_lender ).forEach( async ( item, index ) => {
                    if ( item == undefined || item == "undefined" ) {
                        delete backups.ready_to_finish_lender[ item ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                        return;
                    }
                    if ( !backups.ready_to_finish_lender[ item ][ 5 ] ) {
                        delete backups.ready_to_finish_lender[ item ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                        return;
                    }
                    var contract = backups.ready_to_finish_lender[ item ][ 5 ];
                    var contract_started = await addressOnceHadMoney( contract, "" );
                    if ( !( item in backups.ready_to_finish_lender ) ) return;
                    if ( current_blockheight > backups.ready_to_finish_lender[ item ][ 0 ] && !contract_started ) {
                        if ( !( item in backups.ready_to_finish_lender ) ) return;
                        delete backups.ready_to_finish_lender[ item ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                        return;
                    }
                    //check if address sent money
                    var contract_is_fulfilled = await addressOnceSentMoney( contract, "" );
                    if ( contract_is_fulfilled ) {
                        delete backups.ready_to_finish_lender[ item ];
                        localStorage[ "backups" ] = JSON.stringify( backups );
                    }
                });
            }

            async function addressOnceSentMoney( address, network ) {
                var nonjson = await getData( "https://mutinynet.com/" + network + "api/address/" + address );
                var json = JSON.parse( nonjson );
                if ( json[ "chain_stats" ][ "spent_txo_count" ] > 0 || json[ "mempool_stats" ][ "spent_txo_count" ] > 0 ) {
                    return true;
                }
                return false;
            }

            var displayActiveContracts = async () => {
                if ( displaying_active_contracts_borrower ) return;
                displaying_active_contracts_borrower = true;
                if ( Object.keys( backups.ready_to_finish ).length ) {
                    $( '.active_contracts_div' ).classList.remove( "hidden" );
                    if ( $( '.modal' ) && !$( '.modal' ).classList.contains( "hidden" ) && $( '.modal' ).innerHTML.includes( "progressOutline" ) ) {
                        showProgress( 7, 7, `done` );
                        await waitSomeSeconds( 2 );
                        $( '.x_modal' ).click();
                    }
                } else {
                    $( '.active_contracts' ).innerHTML = "";
                    $( '.active_contracts_div' ).classList.add( "hidden" );
                }
                var current_blockheight = await getBlockheight( "" );
                var div_0 = document.createElement( "div" );
                var i; for ( i=0; i<Object.keys( backups.ready_to_finish ).length; i++ ) {
                    var item = Object.keys( backups.ready_to_finish )[ i ];
                    var contract = backups.ready_to_finish[ item ][ 1 ][ "msg" ][ "contract" ];
                    var address_once_sent_money = await addressOnceSentMoney( contract, "" );
                    if ( address_once_sent_money ) continue;
                    var address_once_had_money = await addressOnceHadMoney( contract, "" );
                    if ( !address_once_had_money ) continue;
                    var principle = backups.ready_to_finish[ item ][ 1 ][ "msg" ][ "principle" ];
                    var timelock = backups.ready_to_finish[ item ][ 1 ][ "msg" ][ "timelock" ];
                    var fee_to_borrow = backups.ready_to_finish[ item ][ 1 ][ "original_offer" ][ "fee_to_borrow" ];
                    var duration_of_loan = backups.ready_to_finish[ item ][ 1 ][ "original_offer" ][ "duration_of_loan" ];
                    var repayment_value = Math.round( principle * Number( `1.${fee_to_borrow}` ) );
                    var due_timestamp = estimateTimestampBasedOnBlockheight( timelock, current_blockheight );
                    var due_date = new Date( due_timestamp * 1000 ).toLocaleDateString();
                    var txinfo = await addressReceivedMoneyInThisTx( contract, "" );
                    if ( !txinfo[ 0 ] ) continue;
                    var received_info = await getData( `https://mutinynet.com/api/tx/${txinfo[ 0 ]}` );
                    var received_status = JSON.parse( received_info )[ "status" ];
                    if ( received_status && "block_height" in received_status ) {
                        var received_block = received_status[ "block_height" ];
                        // var received_hr_timestamp = estimateTimestampBasedOnBlockheight( received_block, current_blockheight );
                        var received_hr_timestamp = received_status[ "block_time" ];
                        var received_date = new Date( received_hr_timestamp * 1000 ).toLocaleDateString();
                    } else {
                        var received_block = current_blockheight;
                        var received_date = new Date().toLocaleDateString();
                    }
                    var my_balance = await getBalanceFromUtxos( backups.utxos );
                    var time_left = timelock - current_blockheight;
                    var time_left_hr_version = convertHMS( time_left * 10 * 60 );
                    var enough_or_not = "";
                    var pay_it_off = `-- <span class="top_up" style="color: blue; text-decoration: underline; cursor: pointer;" onclick="$( '.receive' ).click()">top up</span>`;
                    if ( !( item in backups.ready_to_finish ) ) continue;
                    var utxos_for_this_transaction = backups.ready_to_finish[ item ][ 1 ][ "msg" ][ "utxos" ];
                    if ( repayment_value > my_balance ) enough_or_not = "not ";
                    else pay_it_off = `-- <span class="pay_it_off" data-ins_and_outs="${textToHex( JSON.stringify( backups.ready_to_finish[ item ][ 0 ] ) )}" data-lender="${backups.ready_to_finish[ item ][ 2 ]}" data-lenders_sig="${backups.ready_to_finish[ item ][ 3 ]}" data-custom_utxo="${utxos_for_this_transaction[ 0 ][ "txid" ] + utxos_for_this_transaction[ 0 ][ "vout" ]}" data-duration_of_loan="${duration_of_loan}" style="color: blue; text-decoration: underline; cursor: pointer;">Pay it off</span>`;
                    var time_left = Number( item ) - current_blockheight;
                    var block_or_blocks = "blocks";
                    if ( time_left == 1 ) block_or_blocks = "block";
                    if ( time_left < 1 ) time_left = 0;
                    var html = ``;
                    html = html + `<p>Contract: ${contract}</p>`;
                    html = html + `<p>Principle: ${principle} sats</p>`;
                    html = html + `<p>Fee you'll pay: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    html = html + `<p>You have: ${my_balance} sats, which is ${enough_or_not}enough ${pay_it_off}</p>`;
                    html = html + `<p>Contract was created in: block ${received_block} (~${received_date})</p>`;
                    html = html + `<p>Repay before this block: block ${item} (~${due_date})</p>`;
                    html = html + `<p>Current block: block ${current_blockheight}</p>`;
                    html = html + `<p>Time left: ${time_left} ${block_or_blocks} (~${time_left_hr_version})</p>`;
                    var div = document.createElement( "div" );
                    div.classList.add( "active_contract" );
                    div.classList.add( "bordered" );
                    div.innerHTML = html;
                    div_0.append( div );
                }
                if ( div_0.childNodes.length ) $( '.active_contracts' ).innerHTML = "";
                $( '.active_contracts' ).innerHTML = div_0.innerHTML;
                $$( '.pay_it_off' ).forEach( item => {
                    item.onclick = async e => {
                        var ins_and_outs = JSON.parse( hexToText( e.target.getAttribute( "data-ins_and_outs" ) ) );
                        var lender = e.target.getAttribute( "data-lender" );
                        var lenders_sig = e.target.getAttribute( "data-lenders_sig" );
                        var custom_utxo = e.target.getAttribute( "data-custom_utxo" );
                        var duration_of_loan = e.target.getAttribute( "data-duration_of_loan" );
                        var inputs = ins_and_outs[ 0 ];
                        var outputs = ins_and_outs[ 1 ];
                        var i; for ( i=0; i<backups.utxos.length; i++ ) {
                            var utxo = backups.utxos[ i ];
                            inputs.push({
                                txid: utxo[ "tx_id" ],
                                vout: utxo[ "output_number" ],
                                prevout: {
                                    value: utxo[ "amount" ],
                                    scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                                },
                            });
                        }
                        var sum_of_values = 0;
                        inputs.forEach( item => sum_of_values = sum_of_values + item[ "prevout" ][ "value" ] );
                        var backup_words = backups[ "backup_words" ];
                        var change_address = await alt_getFirstUnusedChangeAddress( backup_words, "testnet/" );
                        var txsize = 0;
                        inputs.forEach( item => txsize = txsize + 64 + 32 + 8 );
                        var i; for ( i=0; i<outputs.length; i++ ) {
                            //I calculate that outputs add 37 bytes apiece by
                            //assuming the average scriptpubkey is 33 bytes
                            //and assuming amounts are denoted in 4 bytes
                            txsize = txsize + 37;
                        }
                        var fee_options = await getThreeFeeRates( "" );
                        sessionStorage.removeItem( "modal_cleared" );
                        sessionStorage.removeItem( "sats_per_byte" );
                        showModal( `<p>Please enter a fee rate as a number. Specifically, the number of sats per byte you want to pay. The minimum rate is ${fee_options[ 0 ]}, the average rate is ${fee_options[ 1 ]}, and the urgent rate is ${fee_options[ 2 ]}.</p><p><input class="modal_sats_per_byte"></p><p><button class="modal_submit_sats_per_byte" onclick="sessionStorage.sats_per_byte = $( '.modal_sats_per_byte' ).value;sessionStorage.modal_cleared = true;">Submit</button></p>`, true );
                        $( '.x_modal' ).classList.add( "hidden" );
                        await getNote( "modal_cleared" );
                        modalVanish();
                        $( '.x_modal' ).classList.remove( "hidden" );
                        var sats_per_byte = Number( sessionStorage[ "sats_per_byte" ] );
                        sessionStorage.removeItem( "sats_per_byte" );
                        if ( !sats_per_byte ) return showModal( "You entered an invalid fee rate. You must enter a number greater than 0, such as 5, 10, or 25. Please try again." );
                        var mining_fee = txsize * sats_per_byte;
                        if ( mining_fee < 172 ) mining_fee = 172;
                        outputs[ 1 ][ "value" ] = sum_of_values - outputs[ 0 ][ "value" ] - mining_fee;
                        outputs[ 1 ][ "scriptPubKey" ] = tapscript.Address.toScriptPubKey( change_address );
                        var repayment_txdata = tapscript.Tx.create({
                            vin: inputs,
                            vout: outputs,
                        });
                        var script_timelock = convertNumToScript( timelock );
                        var scripts = [
                            [ script_timelock, 'OP_CHECKLOCKTIMEVERIFY', 'OP_DROP', lender, 'OP_CHECKSIG' ],
                            [ 0, lender, 'OP_CHECKSIGADD', pubKey, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ],
                            [ 'OP_RETURN', custom_utxo ],
                        ];
                        var tree = scripts.map(s => tapscript.Tap.encodeScript(s));
                        var pubkey = "ab".repeat( 32 );
                        var script = scripts[ 1 ];
                        var target = tapscript.Tap.encodeScript(script);
                        var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                        var sig = tapscript.Signer.taproot.sign( privKey, repayment_txdata, 0, { extension: target } ).hex;
                        repayment_txdata.vin[ 0 ].witness = [ sig, lenders_sig, script, cblock ];
                        var sighash = await tapscript.Signer.taproot.hash( repayment_txdata, 0, { extension: target } );
                        var isValid = await nobleSecp256k1.schnorr.verify( sig, sighash.hex, pubKey );
                        if ( !isValid ) return showModal( `Oh no, your signture for the repayment tx was invalid! Ask a developer for help` );
                        var my_sigs = [];
                        var i; for ( i=0; i<backups.utxos.length; i++ ) {
                            var [ tseckey ] = tapscript.Tap.getSecKey( backups.utxos[ i ][ "privkey" ] );
                            my_sigs.push( tapscript.Signer.taproot.sign( tseckey, repayment_txdata, i + 1 ).hex );
                            repayment_txdata.vin[ i + 1 ].witness = [ my_sigs[ i ] ];
                        }
                        var txhex = tapscript.Tx.encode( repayment_txdata ).hex;
                        var txid = await pushBTCpmt( txhex, "" );
                        if ( txid.includes( "error" ) ) return showModal( `<p>Oh no! There was an error with your transaction, please try again. Here is the error message:</p><p>${txid}</p><p>Hint: if you tried to pay off a loan right after making it, you should probably wait a few minutes for your utxo set to update. It often takes about 2 minutes and it may say "you have 0 sats" for a little bit too before it updates.</p>` );
                        showModal( `Success! Here is your txid: <a href="https://mutinynet.com/tx/${txid}" target="_blank">https://mutinynet.com/tx/${txid}</a>` );
                    }
                });
                displaying_active_contracts_borrower = false;
            }

            function textToHex( text ) {
                var encoder = new TextEncoder().encode( text );
                return [...new Uint8Array(encoder)]
                    .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                    .join( "" );
            }

            function hexToText( hex ) {
                var bytes = new Uint8Array(Math.ceil(hex.length / 2));
                for (var i = 0; i < hex.length; i++) bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
                var text = new TextDecoder().decode( bytes );
                return text;
            }

            var displayActiveContractsLender = async () => {
                if ( displaying_active_contracts_lender ) return;
                displaying_active_contracts_lender = true;
                if ( Object.keys( backups.ready_to_finish_lender ).length ) {
                    var an_addy_had_money_and_didnt_send_it_yet = false;
                    var i; for ( i=0; i<Object.keys( backups.ready_to_finish_lender ).length; i++ ) {
                        var item = Object.keys( backups.ready_to_finish_lender )[ i ];
                        var address = backups.ready_to_finish_lender[ item ][ 5 ];
                        var address_once_sent_money = await addressOnceSentMoney( address, "" );
                        if ( address_once_sent_money ) continue;
                        var address_once_had_money = await addressOnceHadMoney( address, "" );
                        if ( !address_once_had_money ) continue;
                        an_addy_had_money_and_didnt_send_it_yet = true;
                    }
                    if ( an_addy_had_money_and_didnt_send_it_yet ) {
                        $( '.active_contracts_lender_div' ).classList.remove( "hidden" );
                    }
                }
                else {
                    $( '.active_contracts_lender' ).innerHTML = "";
                    $( '.active_contracts_lender_div' ).classList.add( "hidden" );
                }
                var current_blockheight = await getBlockheight( "" );
                var div_0 = document.createElement( "div" );
                var i; for ( i=0; i<Object.keys( backups.ready_to_finish_lender ).length; i++ ) {
                    var item = Object.keys( backups.ready_to_finish_lender )[ i ];
                    var contract = backups.ready_to_finish_lender[ item ][ 5 ];
                    var address_once_sent_money = await addressOnceSentMoney( contract, "" );
                    if ( address_once_sent_money ) continue;
                    var address_once_had_money = await addressOnceHadMoney( contract, "" );
                    if ( !address_once_had_money ) continue;
                    var accept_msg = backups.ready_to_finish_lender[ item ][ 6 ];
                    if ( !backups.ready_to_finish_lender[ item ][ 7 ] ) continue;
                    var original_offer = backups.ready_to_finish_lender[ item ][ 7 ];
                    var borrower = backups.ready_to_finish_lender[ item ][ 8 ];
                    var original_offer_id = backups.ready_to_finish_lender[ item ][ 9 ];
                    var principle = accept_msg[ "principle" ];
                    var timelock = accept_msg[ "timelock" ];
                    try {
                        var fee_to_borrow = original_offer[ "fee_to_borrow" ];
                    } catch( e ) {
                        if ( original_offer_id ) {
                            console.log( `Someone tried to take one of your offers but you got rid of it -- this one: ${original_offer_id}` );
                            continue;
                        }
                        if ( !Object.keys( backups.my_offers ).length ) {
                            console.log( `unknown error, please refresh your browser. If this error persists, ask a developer for help.` );
                            continue;
                        }
                    }
                    var duration_of_loan = original_offer[ "duration_of_loan" ];
                    var collateral_for_loan = original_offer[ "collateral_for_loan" ];
                    var collateral_requirement = principle * Number( ( collateral_for_loan / 100 ).toFixed( 2 ) );
                    var repayment_value = Math.round( principle * Number( `1.${fee_to_borrow}` ) );
                    var my_balance = await getBalanceFromUtxos( backups.utxos );
                    var txinfo = await addressReceivedMoneyInThisTx( contract, "" );
                    //I ensured purgeOldContracts removes contracts where the borrower never deposited
                    //but only after the timelock expires -- otherwise they could deposit money there after
                    //waiting til I am likely to delete the contract, and I will never get my money back
                    if ( !txinfo[ 0 ] ) continue;
                    var received_info = await getData( `https://mutinynet.com/api/tx/${txinfo[ 0 ]}` );
                    var received_status = JSON.parse( received_info )[ "status" ];
                    if ( received_status && "block_height" in received_status ) {
                        var received_block = received_status[ "block_height" ];
                        // var received_hr_timestamp = estimateTimestampBasedOnBlockheight( received_block, current_blockheight );
                        var received_hr_timestamp = received_status[ "block_time" ];
                        var received_date = new Date( received_hr_timestamp * 1000 ).toLocaleDateString();
                    } else {
                        var received_block = current_blockheight;
                        var received_date = new Date().toLocaleDateString();
                    }
                    var blocks_since_confirmed = await howManyConfs( txinfo[ 0 ], "" );
                    var due_timestamp = estimateTimestampBasedOnBlockheight( timelock, current_blockheight );
                    var due_date = new Date( due_timestamp * 1000 ).toLocaleDateString();
                    if ( !( item in backups.ready_to_finish_lender ) ) continue;
                    var time_left = timelock - current_blockheight;
                    var time_left_hr_version = convertHMS( time_left * 10 * 60 );
                    var real_time_left = Number( String( time_left ) );
                    var block_or_blocks = "blocks";
                    if ( time_left == 1 ) block_or_blocks = "block";
                    if ( time_left < 1 ) time_left = 0;
                    var utxos_for_this_transaction = accept_msg[ "utxos" ];
                    var html = ``;
                    html = html + `<p>Contract: ${contract}</p>`;
                    html = html + `<p>Principle: ${principle} sats</p>`;
                    html = html + `<p>Fee you'll earn: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    html = html + `<p>Or you'll get: ${collateral_requirement} sats (if the borrower fails to pay)</p>`;
                    html = html + `<p>You currently have: ${my_balance} sats</p>`;
                    html = html + `<p>You will have: ${my_balance + repayment_value} sats</p>`;
                    html = html + `<p>Or: ${my_balance + collateral_requirement} sats (if the borrower fails to pay)</p>`;
                    html = html + `<p>Contract was created in: block ${received_block} (~${received_date})</p>`;
                    html = html + `<p>When payment is due: block ${timelock} (~${due_date})</p>`;
                    html = html + `<p>Current block: block ${current_blockheight}</p>`;
                    html = html + `<p>Time til then: ${time_left} ${block_or_blocks} (~${time_left_hr_version})</p>`;
                    if ( !time_left ) html = html + `<p>Time's up! <span class="take_collateral" data-can_or_cant="can" data-vin="${textToHex( JSON.stringify( backups.ready_to_finish_lender[ item ][ 1 ] ) )}" data-borrower="${borrower}" data-custom_utxo="${utxos_for_this_transaction[ 0 ][ "txid" ] + utxos_for_this_transaction[ 0 ][ "vout" ]}" data-timelock="${timelock}" data-target="${backups.ready_to_finish_lender[ item ][ 2 ]}" data-script="${textToHex( JSON.stringify( backups.ready_to_finish_lender[ item ][ 3 ] ) )}" data-cblock="${backups.ready_to_finish_lender[ item ][ 4 ]}" style="color: blue; text-decoration: underline; cursor: pointer;">Take the collateral</span></p>`;
                    else html = html + `<p>You can't <span class="take_collateral" data-can_or_cant="cant" data-vin="${textToHex( JSON.stringify( backups.ready_to_finish_lender[ item ][ 1 ] ) )}" data-borrower="${borrower}" data-custom_utxo="${utxos_for_this_transaction[ 0 ][ "txid" ] + utxos_for_this_transaction[ 0 ][ "vout" ]}" data-timelock="${timelock}" data-target="${backups.ready_to_finish_lender[ item ][ 2 ]}" data-script="${textToHex( JSON.stringify( backups.ready_to_finish_lender[ item ][ 3 ] ) )}" data-cblock="${backups.ready_to_finish_lender[ item ][ 4 ]}" style="color: blue; text-decoration: underline; cursor: pointer;">take the collateral</span> til the borrower runs out of time to repay you, but you can try anyway</p>`;
                    var div = document.createElement( "div" );
                    div.setAttribute( "data-contract", contract );
                    div.classList.add( "active_contract_lender" );
                    div.classList.add( "bordered" );
                    div.innerHTML = html;
                    div_0.append( div );
                }
                if ( div_0.children.length ) $( '.active_contracts_lender' ).innerHTML = div_0.innerHTML;
                $$( '.take_collateral' ).forEach( item => {
                    item.onclick = async e => {
                        var can_or_cant = e.target.getAttribute( "data-can_or_cant" );
                        var inputs = JSON.parse( hexToText( e.target.getAttribute( "data-vin" ) ) );
                        var borrower = e.target.getAttribute( "data-borrower" );
                        var custom_utxo = e.target.getAttribute( "data-custom_utxo" );
                        var timelock = Number( e.target.getAttribute( "data-timelock" ) );
                        var target = e.target.getAttribute( "data-target" );
                        var script = JSON.parse( hexToText( e.target.getAttribute( "data-script" ) ) );
                        var cblock = e.target.getAttribute( "data-cblock" );
                        var outputs = [];
                        var sum_of_values = 0;
                        inputs.forEach( item => sum_of_values = sum_of_values + item[ "prevout" ][ "value" ] );
                        var backup_words = backups[ "backup_words" ];
                        var change_address = await alt_getFirstUnusedChangeAddress( backup_words, "testnet/" );
                        //there is only 1 output and 1 output so I just add 104 bytes for the input and, for the output, 33 bytes for the scriptPubkey and 4 bytes for the value
                        var txsize = 64 + 32 + 8;
                        txsize = txsize + 37;
                        var fee_options = await getThreeFeeRates( "" );
                        sessionStorage.removeItem( "modal_cleared" );
                        sessionStorage.removeItem( "sats_per_byte" );
                        showModal( `<p>Please enter a fee rate as a number. Specifically, the number of sats per byte you want to pay. The minimum rate is ${fee_options[ 0 ]}, the average rate is ${fee_options[ 1 ]}, and the urgent rate is ${fee_options[ 2 ]}.</p><p><input class="modal_sats_per_byte"></p><p><button class="modal_submit_sats_per_byte" onclick="sessionStorage.sats_per_byte = $( '.modal_sats_per_byte' ).value;sessionStorage.modal_cleared = true;">Submit</button></p>`, true );
                        $( '.x_modal' ).classList.add( "hidden" );
                        await getNote( "modal_cleared" );
                        modalVanish();
                        $( '.x_modal' ).classList.remove( "hidden" );
                        var sats_per_byte = Number( sessionStorage[ "sats_per_byte" ] );
                        sessionStorage.removeItem( "sats_per_byte" );
                        if ( !sats_per_byte ) return showModal( "You entered an invalid fee rate. You must enter a number greater than 0, such as 5, 10, or 25. Please try again." );
                        var mining_fee = txsize * sats_per_byte;
                        if ( mining_fee < 172 ) mining_fee = 172;
                        var outputs = [{
                            value: sum_of_values - mining_fee,
                            scriptPubKey: tapscript.Address.toScriptPubKey( change_address ),
                        }];
                        var seizure_txdata = tapscript.Tx.create({
                            vin: inputs,
                            vout: outputs,
                            locktime: timelock,
                        });
                        var script_timelock = convertNumToScript( timelock );
                        var scripts = [
                            [ script_timelock, 'OP_CHECKLOCKTIMEVERIFY', 'OP_DROP', pubKey, 'OP_CHECKSIG' ],
                            [ 0, pubKey, 'OP_CHECKSIGADD', borrower, 'OP_CHECKSIGADD', 2, 'OP_EQUAL' ],
                            [ 'OP_RETURN', custom_utxo ],
                        ];
                        var tree = scripts.map(s => tapscript.Tap.encodeScript(s));
                        var pubkey = "ab".repeat( 32 );
                        var [ tpubkey ] = tapscript.Tap.getPubKey(pubkey, { tree });
                        var sig = tapscript.Signer.taproot.sign( privKey, seizure_txdata, 0, { extension: target } ).hex;
                        seizure_txdata.vin[ 0 ].witness = [ sig, script, cblock ];
                        var sighash = await tapscript.Signer.taproot.hash( seizure_txdata, 0, { extension: target } );
                        var isValid = await nobleSecp256k1.schnorr.verify( sig, sighash.hex, pubKey );
                        if ( !isValid ) return showModal( `Oh no, your signture for the repayment tx was invalid! Ask a developer for help` );
                        var txhex = tapscript.Tx.encode( seizure_txdata ).hex;
                        if ( can_or_cant == "can" ) {
                            var txid = await pushBTCpmt( txhex, "" );
                            return showModal( `Success! Here is your txid: <a href="https://mutinynet.com/tx/${txid}" target="_blank">https://mutinynet.com/tx/${txid}</a>` );
                        } else return showModal( `<p>Go here: <a href="https://mutinynet.com/tx/push" target="_blank">https://mutinynet.com/tx/push</a></p><p>And try to broadcast this transaction:</p><p>${txhex}</p>` );
                    }
                });
                displaying_active_contracts_lender = false;
            }

            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }

            async function pushBTCpmt( rawtx, network ) {
                var txid = await postData( "https://mutinynet.com/" + network + "api/tx", rawtx );
                return txid;
            }

            async function howManyConfs( txid, network ) {
                var blockheight = await getBlockheight( network );
                return new Promise( function( resolve, reject ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && ( this.status > 199 && this.status < 300 ) ) {
                            var json = JSON.parse( xhttp.responseText );
                            if ( json[ "status" ][ "confirmed" ] ) {
                                resolve( ( Number( blockheight ) - Number( json[ "status" ][ "block_height" ] ) ) + 1 );
                            } else {
                                resolve( "0".toString() );
                            }
                        } else {
                            if ( this.status > 399 ) {
                                resolve( "ejected from mempool" );
                            }
                        }
                    };
                    xhttp.open( "GET", `https://mutinynet.com/${network}api/tx/` + txid, true );
                    xhttp.send();
                });
            }

            async function addressReceivedMoneyInThisTx( address, network ) {
                var txid;
                var vout;
                var amt;
                var nonjson = await getData( "https://mutinynet.com/" + network + "api/address/" + address + "/txs" );
                var json = JSON.parse( nonjson);
                json.forEach( tx => {
                    tx["vout"].forEach( ( output, index ) => {
                        if ( output[ "scriptpubkey_address" ] == address ) {
                            txid = tx[ "txid" ];
                            vout = index;
                            amt = output[ "value" ];
                        }
                    });
                });
                return [txid, vout, amt];
            }

            var reverseHexString = s => s.match(/[a-fA-F0-9]{2}/g).reverse().join('');

            var convertNumToScript = num => {
                if ( num > 99999 ) num = num.toString( 16 )
                else return num;
                if ( num.length % 2 ) num = "0" + num;
                num = reverseHexString( num );
                return num;
            }

            function modalVanish() {
                $( ".black-bg" ).classList.add( "hidden" );
                $( ".modal" ).classList.add( "hidden" );
            }
            
            function showModal( content, block_til_clear ) {
                if ( block_til_clear ) var fn = `modalVanish();sessionStorage[ 'modal_cleared' ] = true;`; else var fn = `modalVanish();`;
                $( ".modal" ).innerHTML = `<div class="x_modal" style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="${fn}">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: auto; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).classList.remove( "hidden" );
                $( ".modal" ).classList.remove( "hidden" );
            }

            var showProgress = ( num, total, msg ) => {
                var percent = ( ( num / total ) * 100 ).toFixed( 2 );
                if ( num == 1 ) {
                    showModal( `<div class="progress">
                        <h2>Progress bar <span id="goal" style="font-size: .8em; font-weight: normal;"></span></h2>
                        <div class="progressOutline" style="height: 2em; border: 1px solid grey; border-radius: 25px; overflow: hidden;">
                            <div class="progressBar" style="height: 2em; background-color: #61eb34; width: 0%; transition: width 1s;">
                            </div>
                        </div>
                        <div class="progress_status"></div>
                    </div>
                    ` );
                }
                $( '.progressBar' ).style.width = `${percent}%`;
                $( '.progress_status' ).innerText = msg;
            }

            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }

            var displayHistory = async () => {
                if ( Object.keys( backups.user_history[ "loan_history" ] ).length ) {
                    $( '.historical_loan_contracts_label' ).classList.remove( "hidden" );
                    $( '.historical_loan_contracts' ).classList.remove( "hidden" );
                    $( '.view_history' ).classList.remove( "hidden" );
                }
                if ( Object.keys( backups.user_history[ "borrow_history" ] ).length ) {
                    $( '.historical_borrow_contracts_label' ).classList.remove( "hidden" );
                    $( '.historical_borrow_contracts' ).classList.remove( "hidden" );
                    $( '.view_history' ).classList.remove( "hidden" );
                }
                var borrow_profits = 0;
                var borrow_losses = 0;
                var html_for_historical_borrows = document.createElement( "div" );
                var current_blockheight = await getBlockheight( "" );
                var i; for ( i=0; i<Object.keys( backups.user_history[ "borrow_history" ] ).length; i++ ) {
                    var item = Object.keys( backups.user_history[ "borrow_history" ] )[ i ];
                    var contract = backups.user_history[ "borrow_history" ][ item ][ "msg" ][ "contract" ];
                    var principle = backups.user_history[ "borrow_history" ][ item ][ "msg" ][ "principle" ];
                    var timelock = backups.user_history[ "borrow_history" ][ item ][ "msg" ][ "timelock" ];
                    var fee_to_borrow = backups.user_history[ "borrow_history" ][ item ][ "original_offer" ][ "fee_to_borrow" ];
                    var duration_of_loan = backups.user_history[ "borrow_history" ][ item ][ "original_offer" ][ "duration_of_loan" ];
                    var collateral_for_loan = backups.user_history[ "borrow_history" ][ item ][ "original_offer" ][ "collateral_for_loan" ];
                    var collateral_requirement = principle * Number( ( collateral_for_loan / 100 ).toFixed( 2 ) );
                    var repayment_value = Math.round( principle * Number( `1.${fee_to_borrow}` ) );
                    var due_timestamp = estimateTimestampBasedOnBlockheight( timelock, current_blockheight );
                    var due_date = new Date( due_timestamp * 1000 ).toLocaleDateString();
                    var txinfo = await addressReceivedMoneyInThisTx( contract, "" );
                    if ( !txinfo[ 0 ] ) continue;
                    var received_info = await getData( `https://mutinynet.com/api/tx/${txinfo[ 0 ]}` );
                    var received_status = JSON.parse( received_info )[ "status" ];
                    if ( received_status && "block_height" in received_status ) {
                        var received_block = received_status[ "block_height" ];
                        // var received_hr_timestamp = estimateTimestampBasedOnBlockheight( received_block, current_blockheight );
                        var received_hr_timestamp = received_status[ "block_time" ];
                        var received_date = new Date( received_hr_timestamp * 1000 ).toLocaleDateString();
                    } else {
                        var received_block = current_blockheight;
                        var received_date = new Date().toLocaleDateString();
                    }
                    var status = "in progress";
                    var txid_of_spending_tx = await addressSentMoneyInThisTx( contract, txinfo[ 0 ], "" );
                    if ( txid_of_spending_tx ) status = "paid off";
                    if ( txid_of_spending_tx ) var more_info = await getData( `https://mutinynet.com/api/tx/${txid_of_spending_tx}` );
                    if ( more_info ) var amount_sent = JSON.parse( more_info )[ "vout" ][ 0 ][ "value" ];
                    if ( more_info ) var tx_status = JSON.parse( more_info )[ "status" ];
                    if ( tx_status && "block_height" in tx_status ) {
                        var settlement_block = tx_status[ "block_height" ];
                        // var settlement_hr_timestamp = estimateTimestampBasedOnBlockheight( settlement_block, current_blockheight );
                        var settlement_hr_timestamp = tx_status[ "block_time" ];
                        var settlement_date = new Date( settlement_hr_timestamp * 1000 ).toLocaleDateString();
                        var settlement_text = `block ${settlement_block} (~${settlement_date})`;
                    } else var settlement_text = "the transaction is in the mempool and will be settled when it confirms";
                    //TODO: the following lines assume that if the amount_sent is more than the repayment
                    //value then the lender got the collateral. But that will not necessarily be true if
                    //the collateral_requirement was 100% of the repayment_value or less. Fix that assumption.
                    if ( txid_of_spending_tx && amount_sent && amount_sent > repayment_value ) status = "took collateral";
                    if ( amount_sent && amount_sent > repayment_value ) var losses_on_this_loan = collateral_requirement - principle;
                    if ( amount_sent && amount_sent <= repayment_value ) var losses_on_this_loan = repayment_value - principle;
                    if ( amount_sent && status != "in progress" ) borrow_losses = borrow_losses + losses_on_this_loan;
                    var time_left = timelock - current_blockheight;
                    var time_left_hr_version = convertHMS( time_left * 10 * 60 );
                    var block_or_blocks = "blocks";
                    if ( time_left == 1 ) block_or_blocks = "block";
                    if ( time_left < 1 ) time_left = 0;
                    var html = ``;
                    html = html + `<p>Contract: ${contract}</p>`;
                    html = html + `<p>Principle: ${principle} sats</p>`;
                    if ( status == "in progress" ) html = html + `<p>Fee you'll pay: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    if ( status == "paid off" ) html = html + `<p>Fee you paid: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    if ( status == "took collateral" ) html = html + `<p>You did not repay, so they took your collateral, which was: ${collateral_requirement} sats</p>`;
                    if ( status != "in progress" ) html = html + `<p>Losses on this loan: ${losses_on_this_loan} sats</p>`;
                    html = html + `<p>Contract was created in: block ${received_block} (~${received_date})</p>`;
                    if ( status == "in progress" ) html = html + `<p>Repay before this block: block ${timelock} (~${due_date})</p>`;
                    else html = html + `<p>When payment was due: block ${timelock} (~${due_date})</p>`;
                    if ( status == "in progress" ) html = html + `<p>Current block: block ${current_blockheight}</p>`;
                    else html = html + `<p>When contract settled: ${settlement_text}</p>`;
                    if ( status == "in progress" ) html = html + `<p>Time left: ${time_left} ${block_or_blocks} (~${time_left_hr_version})</p>`;
                    if ( !i ) html_for_historical_borrows.innerHTML = "";
                    var div = document.createElement( "div" );
                    div.classList.add( "historical_contract" );
                    div.classList.add( "bordered" );
                    div.innerHTML = html;
                    html_for_historical_borrows.append( div );
                }
                $( '.historical_borrow_contracts' ).innerHTML = `<p>Profits: ${borrow_profits} sats</p><p>Losses: ${borrow_losses} sats</p>`;
                $( '.historical_borrow_contracts' ).append( html_for_historical_borrows );
                var loan_profits = 0;
                var loan_losses = 0;
                var html_for_historical_loans = document.createElement( "div" );
                var current_blockheight = await getBlockheight( "" );
                var i; for ( i=0; i<Object.keys( backups.user_history[ "loan_history" ] ).length; i++ ) {
                    var item = Object.keys( backups.user_history[ "loan_history" ] )[ i ];
                    var contract = backups.user_history[ "loan_history" ][ item ][ 0 ];
                    var accept_msg = backups.user_history[ "loan_history" ][ item ][ 1 ];
                    var original_offer = backups.user_history[ "loan_history" ][ item ][ 2 ];
                    var original_offer_id = item;
                    var principle = accept_msg[ "principle" ];
                    var timelock = accept_msg[ "timelock" ];
                    try {
                        var fee_to_borrow = original_offer[ "fee_to_borrow" ];
                    } catch( e ) {continue;}
                    var duration_of_loan = original_offer[ "duration_of_loan" ];
                    var collateral_for_loan = original_offer[ "collateral_for_loan" ];
                    var collateral_requirement = principle * Number( ( collateral_for_loan / 100 ).toFixed( 2 ) );
                    var repayment_value = Math.round( principle * Number( `1.${fee_to_borrow}` ) );
                    var txinfo = await addressReceivedMoneyInThisTx( contract, "" );
                    if ( !txinfo[ 0 ] ) continue;
                    var received_info = await getData( `https://mutinynet.com/api/tx/${txinfo[ 0 ]}` );
                    var received_status = JSON.parse( received_info )[ "status" ];
                    if ( received_status && "block_height" in received_status ) {
                        var received_block = received_status[ "block_height" ];
                        // var received_hr_timestamp = estimateTimestampBasedOnBlockheight( received_block, current_blockheight );
                        var received_hr_timestamp = received_status[ "block_time" ];
                        var received_date = new Date( received_hr_timestamp * 1000 ).toLocaleDateString();
                    } else {
                        var received_block = current_blockheight;
                        var received_date = new Date().toLocaleDateString();
                    }
                    var status = "in progress";
                    var txid_of_spending_tx = await addressSentMoneyInThisTx( contract, txinfo[ 0 ], "" );
                    if ( txid_of_spending_tx ) status = "paid off";
                    if ( txid_of_spending_tx ) var more_info = await getData( `https://mutinynet.com/api/tx/${txid_of_spending_tx}` );
                    if ( more_info ) var amount_sent = JSON.parse( more_info )[ "vout" ][ 0 ][ "value" ];
                    if ( more_info ) var tx_status = JSON.parse( more_info )[ "status" ];
                    if ( tx_status && "block_height" in tx_status ) {
                        var settlement_block = tx_status[ "block_height" ];
                        // var settlement_hr_timestamp = estimateTimestampBasedOnBlockheight( settlement_block, current_blockheight );
                        var settlement_hr_timestamp = tx_status[ "block_time" ];
                        var settlement_date = new Date( settlement_hr_timestamp * 1000 ).toLocaleDateString();
                        var settlement_text = `block ${settlement_block} (~${settlement_date})`;
                    } else settlement_text = "the transaction is in the mempool and will be settled when it confirms";
                    //TODO: the following lines assume that if the amount_sent is more than the repayment
                    //value then the lender got the collateral. But that will not necessarily be true if
                    //the collateral_requirement was 100% of the repayment_value or less. Fix that assumption.
                    if ( txid_of_spending_tx && amount_sent && amount_sent > repayment_value ) status = "took collateral";
                    if ( amount_sent && amount_sent > repayment_value ) var profits_on_this_loan = collateral_requirement - principle;
                    if ( amount_sent && amount_sent <= repayment_value ) var profits_on_this_loan = repayment_value - principle;
                    if ( amount_sent && status != "in progress" ) loan_profits = loan_profits + profits_on_this_loan;
                    var blocks_since_confirmed = await howManyConfs( txinfo[ 0 ], "" );
                    var due_timestamp = estimateTimestampBasedOnBlockheight( timelock, current_blockheight );
                    var due_date = new Date( due_timestamp * 1000 ).toLocaleDateString();
                    var time_left = timelock - current_blockheight;
                    var time_left_hr_version = convertHMS( time_left * 10 * 60 );
                    var real_time_left = Number( String( time_left ) );
                    var block_or_blocks = "blocks";
                    if ( time_left == 1 ) block_or_blocks = "block";
                    if ( time_left < 1 ) time_left = 0;
                    var utxos_for_this_transaction = accept_msg[ "utxos" ];
                    var html = ``;
                    html = html + `<p>Contract: ${contract}</p>`;
                    html = html + `<p>Principle: ${principle} sats</p>`;
                    if ( status == "in progress" ) html = html + `<p>Fee you'll earn: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    if ( status == "in progress" ) html = html + `<p>Or you'll get: ${collateral_requirement} sats (if the borrower fails to pay)</p>`;
                    if ( status == "paid off" ) html = html + `<p>Fee you earned: ${fee_to_borrow}% (i.e. ${repayment_value - principle} sats)</p>`;
                    if ( status == "took collateral" ) html = html + `<p>They did not repay, so you took their collateral, which was: ${collateral_requirement} sats</p>`;
                    if ( status != "in progress" ) html = html + `<p>Profits on this loan: ${profits_on_this_loan} sats</p>`;
                    html = html + `<p>Contract was created in: block ${received_block} (~${received_date})</p>`;
                    if ( status == "in progress" ) html = html + `<p>When payment is due: block ${timelock} (~${due_date})</p>`;
                    else html = html + `<p>When payment was due: block ${timelock} (~${due_date})</p>`;
                    if ( status == "in progress" ) html = html + `<p>Current block: block ${current_blockheight}</p>`;
                    else html = html + `<p>When contract settled: ${settlement_text}</p>`;
                    if ( status == "in progress" ) html = html + `<p>Time til then: ${time_left} ${block_or_blocks} (~${time_left_hr_version})</p>`;
                    if ( !i ) html_for_historical_loans.innerHTML = "";
                    var div = document.createElement( "div" );
                    div.classList.add( "historical_contract_lender" );
                    div.classList.add( "bordered" );
                    div.innerHTML = html;
                    html_for_historical_loans.append( div );
                }
                $( '.historical_loan_contracts' ).innerHTML = `<p>Profits: ${loan_profits} sats</p><p>Losses: ${loan_losses} sats</p>`;
                $( '.historical_loan_contracts' ).append( html_for_historical_loans );
            }

            async function addressSentMoneyInThisTx( address, funding_txid, network ) {
                return new Promise( async function( resolve, reject ) {
                    var nonjson = await getData( "https://mutinynet.com/" + network + "/api/address/" + address + "/txs" );
                    json = JSON.parse( nonjson );
                    json.forEach( function( tx ) {
                        tx[ "vin" ].forEach( function( input ) {
                            if ( input[ "txid" ] == funding_txid ) {
                                resolve( tx[ "txid" ] );
                            }
                        });
                    });
                    resolve( "" );
                });
            }
            var checkNostrStatus = () => {
                if ( !( "readyState" in socket ) ) return;
                if ( socket.readyState == 3 ) good_socket = false;
            }
            var addFeeRates = async () => {
                var fee_options = await getThreeFeeRates( "" );
                $( '.min_fee' ).innerText = fee_options[ 0 ];
                $( '.mid_fee' ).innerText = fee_options[ 1 ];
                $( '.max_fee' ).innerText = fee_options[ 2 ];
                if ( fee_modified ) return;
                var minmax = 100;
                var maxmax = Math.round( fee_options[ 2 ] * 1.25 );
                if ( maxmax > minmax ) minmax = maxmax;
                $( ".sats_range" ).max = minmax;
                $( ".sats_range" ).value = fee_options[ 1 ];
                $( ".mining_fee" ).innerText = fee_options[ 1 ];
            }
            function createQR( content ) {
                var dataUriPngImage = document.createElement( "img" ),
                s = QRCode.generatePNG( content, {
                    ecclevel: "M",
                    format: "html",
                    fillcolor: "#FFFFFF",
                    textcolor: "#000000",
                    margin: 4,
                    modulesize: 8,
                });
                dataUriPngImage.src = s;
                dataUriPngImage.className = "qr_code";
                dataUriPngImage.style.width = "100%";
                return dataUriPngImage;
            }
            function convertHMS( value ) {
                if ( value < 0 ) value = 0;
                var sec = parseInt(value, 10); // convert value to number if it's string
                var years = Math.round(sec / 31536000); // get years
                var months = Math.round((sec - (years * 31536000)) / 2592000); // get months
                var days = Math.round((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                var hours = Math.round((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                var yearsstring = (years > 1) ? `years`:`year`;
                var monthsstring = (months > 1) ?  `months`:`month`;
                var daysstring = (days > 1) ? `days`:`day`;
                var hoursstring = (hours > 1) ? `hours`:`hour`;
                var minutesstring = (minutes > 1) ? `minutes`:`minute`;
                var secondsstring = (seconds > 1) ? `seconds`:`second`;
                if ( years > 0 ) return `${years} ${yearsstring}`;
                if ( months > 0 ) return `${months} ${monthsstring}`;
                if ( days > 0 ) return `${days} ${daysstring}`;
                if ( hours > 0 ) return `${hours} ${hoursstring}`;
                if ( minutes > 0 ) return `${minutes} ${minutesstring}`;
                if ( seconds == 0 ) `${seconds} seconds`;
                return `${seconds} ${secondsstring}`;
            }
            var estimateTimestampBasedOnBlockheight = ( blockheight, current_blockheight ) => {
                var now = Math.floor( Date.now() / 1000 );
                var ten_minute_segments = current_blockheight - blockheight;
                var seconds = ten_minute_segments * 10 * 60;
                if ( seconds < 0 ) return now + Math.abs( seconds );
                return now - seconds;
            }
            var extractRecipientFromNostrEvent = event => {
                var recipient = null;
                event.tags.every( item => {
                    if ( item[ 0 ] == "p" ) {
                        recipient = item[ 1 ];
                        return;
                    }
                    return true;
                });
                if ( recipient ) return recipient;
                return "no recipient";
            }
            var extractIdentifierFromNostrEvent = event => {
                var identifier = null;
                event.tags.every( item => {
                    if ( item[ 0 ] == "d" ) {
                        identifier = item[ 1 ];
                        return;
                    }
                    return true;
                });
                if ( identifier ) return identifier;
                return "no identifier";
            }
            var cancelOffer = async offer_id => {
                var offerEvent = {
                    content: "",
                    created_at: Math.floor( Date.now() / 1000 ),
                    kind: 30062,
                    tags: [ [ "d", offer_id ] ],
                    pubkey: pubKey,
                };
                var signedOffer = await getSignedEvent( offerEvent, privKey );
                socket.send(JSON.stringify(['EVENT', signedOffer]));
                delete backups.my_offers[ offer_id ];
                localStorage[ "backups" ] = JSON.stringify( backups );
                $( `div[ data-offer_id="${offer_id}" ]` ).remove();
            }
            function saveData( data, fileName ) {
                var a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                var json = JSON.stringify(data);
                var blob = new Blob([json], {type: "octet/stream"});
                var url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            }
        </script>
        <script>
            var { getSharedSecret, schnorr, utils } = nobleSecp256k1;
            var offer_found = false;
            var relay = "wss://nostrue.com";
            if ( $_GET[ "offer" ] ) {
                var mysec = $_GET[ "offer" ].substring( 0, 64 );
                var mypub = nobleSecp256k1.getPublicKey( mysec, true ).substring( 2 );
                var oid = $_GET[ "offer" ].substring( 64, 128 );
                relay = hexToText( $_GET[ "offer" ].substring( 128 ) );
                setTimeout( () => {
                    if ( !offer_found && !$( '.logout' ).classList.contains( "hidden" ) ) showModal( `It looks like your counterparty's offer expired, please ask them to send a fresh one` );
                    if ( !offer_found && $( '.logout' ).classList.contains( "hidden" ) ) showModal( `It looks like you are logged out, please log in or create an account to view the private offer you clicked on` );
                }, 4000 );
            }
            var privKey, pubKey;
            async function getSignedEvent(event, privateKey) {
                var eventData = JSON.stringify([
                    0,                  // Reserved for future use
                    event['pubkey'],        // The sender's public key
                    event['created_at'],    // Unix timestamp
                    event['kind'],      // Message “kind” or type
                    event['tags'],      // Tags identify replies/recipients
                    event['content']        // Your note contents
                ])
                event.id  = SHA256( eventData );
                event.sig = await schnorr.sign( event.id, privateKey );
                return event;
            }
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = window.crypto.getRandomValues(new Uint8Array(16));
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
        </script>
    </head>
    <body>
        <h1>Welcome to loan shark</h1>
        <div class="homepage">
            <div class="login_buttons">
                <button class="new_account">New account</button>
                <button class="login hidden">Log in</button>
                <button class="import_data">Import</button>
                <button class="logout hidden">Log out</button>
                <button class="manage_wallet hidden">Manage wallet</button>
                <button class="new_loan hidden">New loan</button>
                <button class="view_history hidden">History</button>
                <button class="backup_data hidden">Backup data</button>
            </div>
            <h2>Loan offers</h2>
            <div class="orderbook">
                <p class="nothing_in_orderbook">None yet</p>
            </div>
            <div class="active_contracts_div hidden">
                <h2>Contracts where you are an active borrower</h2>
                <div class="active_contracts"></div>
            </div>
            <div class="active_contracts_lender_div hidden">
                <h2>Contracts where you are an active lender</h2>
                <div class="active_contracts_lender"></div>
            </div>
        </div>
        <div class="wallet hidden">
            <button class="home">Home</button>
            <div class="wallet_div">
                <p class="balance_p">Balance: <span class="balance">loading...</span></p>
                <div class="send_and_receive_buttons">
                    <button class="send">Send</button>
                    <button class="receive">Receive</button>
                </div>
            </div>
        </div>
        <div class="new_loan_page hidden">
            <p><button class="home">Home</button></p>
            <p>
                What is the minimum amount you want to lend? (in sats) Your offer will be a range between your minimum (chosen here) and a maximum (however much you have in your wallet).
            </p>
            <div class="min_to_lend">
                <input type="number" value="546" step="1">
            </div>
            <p>
                Name your fee (as a percentage)
            </p>
            <p><input class="fee_to_borrow" type="number" value="10" step="1" min="0" max="100"></p>
            <p>
                How much collateral must your counterparty post? (as a percentage)
            </p>
            <p><input class="collateral_for_loan" type="number" value="200" step="1" min="1" max="1000"></p>
            <p>
                How long should the loan last?
                <select class="duration_of_loan">
                    <option>3 months</option>
                    <option>6 months</option>
                    <option>12 months</option>
                </select>
            </p>
            <p>
                Keep offer private?
                <input class="privacy_switch" type="checkbox">
            </p>
            <p><button class="submit_loan_offer">Submit</button></p>
        </div>
        <div class="history hidden">
            <button class="home">Home</button>
            <h2 class="historical_loan_contracts_label hidden">Historical loan contracts</h2>
            <div class="historical_loan_contracts hidden"></div>
            <h2 class="historical_borrow_contracts_label hidden">Historical borrow contracts</h2>
            <div class="historical_borrow_contracts hidden"></div>
        </div>
        <div class="send_page hidden">
            <button class="back_to_wallet">Back</button>
            <p class="bold">Destination address</p>
            <p><input class="destino"></p>
            <p class="bold">Amount (in sats)</p>
            <p><input class="amount"></p>
            <p class="bold">Fee rate</p>
            <div class=".sliderange">
                <p>Sats per byte: <span class="mining_fee">1</span></p>
                <input class="sats_range" type="range" min="1" max="100" value="1">
            </div>
            <script>
                $( ".mining_fee" ).innerText = $( ".sats_range" ).value;
                $( ".sats_range" ).oninput = () => {
                    fee_modified = true;
                    $( ".mining_fee" ).innerText = $( ".sats_range" ).value;
                }
            </script>
            <p class="bold">Suggested fee rates</p>
            <p>Min: <span class="min_fee"></span><br>Mid: <span class="mid_fee"></span><br>Max: <span class="max_fee"></span></p>
            <p><button class="send_pmt">Send</button></p>
        </div>
        <script>
            var import_data = file => {
                var fileReader = new FileReader();
                fileReader.onloadend = () => {
                    var b64 = fileReader.result.toString().substring( fileReader.result.toString().indexOf( "base64," ) + 7 );
                    var text = hexToText( base64ToHex( b64 ) );
                    if ( !isValidJson( text ) ) return;
                    backups = JSON.parse( text );
                    localStorage[ "backups" ] = JSON.stringify( backups );
                    $( '.login' ).click();
                    $( '.x_modal' ).click();
                }
                fileReader.readAsDataURL( file );
            }
            $( '.backup_data' ).onclick = () => {
                var fileName = "loan_shark_backup.json";
                saveData( backups, fileName );
            }
            $( '.import_data' ).onclick = () => {
                showModal( `
                    <form>
                        <p style="font-weight: bold;">Upload your backup file</p>
                        <p><input type="file" onchange="{import_data( this.files[ 0 ] );}" /></p>
                    </form>
                ` );
            }
            $$( '.back_to_wallet' ).forEach( item => {
                item.onclick = () => hider( 'wallet' );
            });
            $( '.send_pmt' ).onclick = () => {
                var destino = $( '.destino' ).value;
                if ( !isValidAddress( destino ) ) return showModal( "You entered an invalid bitcoin address. Please try again." );
                var amt = $( '.amount' ).value;
                if ( !amt ) return showModal( "You entered an invalid amount. Please try again." );
                amt = Number( amt );
                if ( amt < 546 ) return showModal( "The amount you entered is invalid or below bitcoin's dust limit of 546 sats. Please try again." );
                var sats_per_byte = $( '.mining_fee' ).innerText;
                sats_per_byte = Number( sats_per_byte );
                if ( !sats_per_byte ) return showModal( "You entered an invalid fee rate. You must enter a number greater than 0, such as 5, 10, or 25. Please try again." );
                spendCoins( destino, amt, sats_per_byte, "testnet/" );
            }
            $( '.submit_loan_offer' ).onclick = async () => {
                var btc_holdings = 0;
                backups.utxos.forEach(  utxo => btc_holdings = btc_holdings + utxo[ "amount" ] );
                var offer = {}
                offer[ "duration_of_loan" ] = Number( $( '.new_loan_page .duration_of_loan' ).value.split( " " )[ 0 ] );
                offer[ "fee_to_borrow" ] = Number( $( '.new_loan_page .fee_to_borrow' ).value );
                offer[ "min_to_lend" ] = Number( $( '.new_loan_page .min_to_lend input' ).value );
                offer[ "max_to_lend" ] = btc_holdings;
                offer[ "collateral_for_loan" ] = Number( $( '.new_loan_page .collateral_for_loan' ).value );
                $( '.home' ).click();
                var identifier = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var offerEvent = {
                    content: JSON.stringify( offer ),
                    created_at: Math.floor( Date.now() / 1000 ),
                    kind: 30062,
                    tags: [ [ "d", identifier ] ],
                    pubkey: pubKey,
                };
                var signedOffer = await getSignedEvent(offerEvent, privKey);
                var make_private = $( '.privacy_switch' ).checked;
                if ( !make_private ) socket.send(JSON.stringify(['EVENT', signedOffer]));
                else offer[ "private" ] = true;
                offer[ "timestamp" ] = Math.floor( Date.now() / 1000 );
                backups.my_offers[ identifier ] = offer;
                localStorage[ "backups" ] = JSON.stringify( backups );
                if ( !make_private ) return;
                var rando_sec = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var rando_pub = nobleSecp256k1.getPublicKey( rando_sec, true ).substring( 2 );
                var encrypted = encrypt( privKey, rando_pub, JSON.stringify( signedOffer ) );
                var privateOffer = {
                    content: encrypted,
                    created_at: Math.floor( Date.now() / 1000 ),
                    kind: 4,
                    tags: [ [ "p", rando_pub ] ],
                    pubkey: pubKey,
                };
                var signedPrivate = await getSignedEvent(privateOffer, privKey);
                socket.send(JSON.stringify(['EVENT', signedPrivate]));
                var shareable_url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + "?offer=" + rando_sec + privateOffer.id + textToHex( relay );
                if ( make_private ) showModal( `<a href="${shareable_url}" target="_blank">Click here</a> for a sharable link to your private offer` );
            }
            $( '.login' ).onclick = async () => {
                if ( !page_loaded ) return;
                var backup_words = backups[ "backup_words" ];
                if ( !backup_words ) {
                    sessionStorage.removeItem( "modal_cleared" );
                    showModal( `<p>Enter your 12 words</p><p><input class="modal_twelve_words"></p><p><button class="modal_submit_twelve_words" onclick="backups.backup_words = $( '.modal_twelve_words' ).value;localStorage.backups = JSON.stringify( backups );sessionStorage.modal_cleared = true;">Submit</button></p>`, true );
                    $( '.x_modal' ).classList.add( "hidden" );
                    await getNote( "modal_cleared" );
                    modalVanish();
                    $( '.x_modal' ).classList.remove( "hidden" );
                    var backup_words = backups[ "backup_words" ];
                }
                if ( !backup_words ) backups[ "backup_words" ] = "";
                localStorage[ "backups" ] = JSON.stringify( backups );
                if ( !backup_words ) return;
                if ( !bip39.validateMnemonic( backup_words ) ) backups[ "backup_words" ] = "";
                if ( !bip39.validateMnemonic( backup_words ) ) localStorage[ "backups" ] = JSON.stringify( backups );
                if ( !bip39.validateMnemonic( backup_words ) ) return showModal( `Your backup words are invalid, try again` );
                var xprv = getXprvFromWords( backup_words, "44'" );
                var keypair = getKeypairFromXprv( xprv, 0 );
                privKey = keypair[ 0 ];
                pubKey = keypair[ 1 ].substring( 2 );
                try {
                    if ( !good_socket ) socket = new WebSocket( relay );
                    good_socket = true;
                } catch ( e ) {}
                socket.addEventListener('message', async message => {
                    var [ type, subId, event ] = JSON.parse( message.data );
                    var { kind, content } = event || {}
                    if ( !event || event === true ) return;
                    if ( messages_handled.includes( event.id ) ) return;
                    messages_handled.push( event.id );
                    var recipient = extractRecipientFromNostrEvent( event );
                    if ( kind === 4 && recipient == pubKey ) content = await decrypt(privKey, event.pubkey, content);
                    if ( kind === 4 && $_GET[ "offer" ] && recipient == mypub ) {
                        content = await decrypt( mysec, event.pubkey, content );
                        content = JSON.parse( content );
                        offer_found = true;
                        return handle30062( content );
                    }
                    if ( kind === 30062 ) return handle30062( event );
                    if ( kind === 4 ) return handle4( content, event.pubkey );
                    else console.log( 'content:', content );
                });
                socket.addEventListener('open', async e => {
                    console.log( "connected to " + relay );
                    var timestamp = Math.floor( Date.now() / 1000 );
                    var timeMinusTen = timestamp - 600;
                    var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 16 );
                    var filter1  = { "#p": [ pubKey ], since: timeMinusTen }
                    if ( !$_GET[ "offer" ] ) var filter2  = { "kinds": [ 30062 ], since: timeMinusTen }
                    else var filter2  = { "ids": [ oid ], since: timeMinusTen }
                    var subscription = [ "REQ", subId, filter1, filter2 ];
                    socket.send(JSON.stringify( subscription ));
                });
                $( '.import_data' ).classList.add( "hidden" );
                $( '.logout' ).classList.remove( "hidden" );
                $( '.manage_wallet' ).classList.remove( "hidden" );
                $( '.new_loan' ).classList.remove( "hidden" );
                $( '.backup_data' ).classList.remove( "hidden" );
            }
            $( '.logout' ).onclick = () => {
                var conf = true;
                if ( !!Object.keys( backups.user_history.loan_history ).length || !!Object.keys( backups.user_history.borrow_history ).length ) conf = confirm( `Logging out will permanently clear your transaction history so make sure you've backed it up first. Click ok to log out or cancel to not do that yet` );
                if ( !conf ) return;
                $( '.import_data' ).classList.remove( "hidden" );
                $( '.logout' ).classList.add( "hidden" );
                $( '.manage_wallet' ).classList.add( "hidden" );
                $( '.new_loan' ).classList.add( "hidden" );
                sessionStorage.clear();
                localStorage.clear();
                backups = {
                    backup_words: "",
                    utxos: [],
                    my_offers: {},
                    ready_to_finish: {},
                    ready_to_finish_lender: {},
                    user_history: {
                        loan_history: {},
                        borrow_history: {},
                    }
                }
                utxos_loaded = false;
                $( '.balance' ).innerText = `loading...`;
            }
            $( '.new_account' ).onclick = async () => {
                var backup_words = backups[ "backup_words" ];
                if ( backup_words ) return showModal( `You already have an account and you are logged in. Log out to make a new one` );
                backups[ "backup_words" ] = generateWords();
                localStorage[ "backups" ] = JSON.stringify( backups );
                var backup_words = backups[ "backup_words" ];
                sessionStorage.removeItem( "modal_cleared" );
                showModal( `<p>Save your private keys or you will lose your money:</p><p>${backup_words}</p>`, true );
                await getNote( "modal_cleared" );
                showModal( `Congratulations, your account is ready and you are logged in` );
                $( '.login' ).click();
            }
            $( '.manage_wallet' ).onclick = () => hider( 'wallet' );
            $$( '.home' ).forEach( item => {
                item.onclick = () => hider( 'homepage' );
            });
            $( '.send' ).onclick = async () => {
                $( '.destino' ).value = "";
                $( '.amount' ).value = "";
                hider( 'send_page' );
            }
            $( '.receive' ).onclick = async () => {
                var backup_words = backups[ "backup_words" ];
                if ( !backup_words ) return;
                var address = await alt_getFirstUnusedReceiveAddress( backup_words, "testnet/" );
                var url = "bitcoin:" + address;
                var a = document.createElement( "a" );
                a.href = url;
                a.target = "_blank";
                var qr = createQR( url.toUpperCase() );
                qr.style.maxWidth = "250px";
                a.append( qr );
                var prep_div = document.createElement( "div" );
                prep_div.append( a );
                var div_html = prep_div.innerHTML;
                var html = `${div_html}`;
                showModal( html + `<p style="max-width: 350px; margin: auto;">${address}</p>` );
            }
            $( '.new_loan' ).onclick = () => {
                $( '.new_loan_page .duration_of_loan' ).value = "3 months";
                $( '.new_loan_page .fee_to_borrow' ).value = "10";
                $( '.new_loan_page .min_to_lend input' ).value = "546";
                $( '.new_loan_page .collateral_for_loan' ).value = "200";
                $( '.new_loan_page .privacy_switch' ).checked = false;
                hider( 'new_loan_page' );
            }
            $( '.view_history' ).onclick = () => hider( 'history' );
            init();
        </script>
        <div class="black-bg hidden"></div>
        <div class="modal hidden"></div>
        <script>
            page_loaded = true;
        </script>
    </body>
</html>
